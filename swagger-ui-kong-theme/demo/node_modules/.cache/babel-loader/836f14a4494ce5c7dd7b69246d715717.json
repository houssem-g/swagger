{"ast":null,"code":"/*\nA small class to stand-in for a stream when you simply want to write to a string.\n */\n\n(function () {\n  var ref,\n    ref1,\n    ref2,\n    slice = [].slice,\n    hasProp = {}.hasOwnProperty;\n  this.StringStream = function () {\n    function StringStream() {\n      this.string = '';\n    }\n    StringStream.prototype.write = function (chunk) {\n      return this.string += chunk;\n    };\n    return StringStream;\n  }();\n  this.clone = function (_this) {\n    return function (obj) {\n      return _this.extend({}, obj);\n    };\n  }(this);\n  this.extend = function () {\n    var destination, i, k, len, source, sources, v;\n    destination = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];\n    for (i = 0, len = sources.length; i < len; i++) {\n      source = sources[i];\n      for (k in source) {\n        v = source[k];\n        destination[k] = v;\n      }\n    }\n    return destination;\n  };\n  this.is_empty = function (obj) {\n    var key;\n    if (Array.isArray(obj) || typeof obj === 'string') {\n      return obj.length === 0;\n    }\n    for (key in obj) {\n      if (!hasProp.call(obj, key)) continue;\n      return false;\n    }\n    return true;\n  };\n  this.inspect = (ref = (ref1 = (ref2 = require('util')) != null ? ref2.inspect : void 0) != null ? ref1 : global.inspect) != null ? ref : function (a) {\n    return \"\" + a;\n  };\n  this.pad_left = function (str, char, length) {\n    str = String(str);\n    if (str.length >= length) {\n      return str;\n    } else if (str.length + 1 === length) {\n      return \"\" + char + str;\n    } else {\n      return \"\" + new Array(length - str.length + 1).join(char) + str;\n    }\n  };\n  this.to_hex = function (num) {\n    if (typeof num === 'string') {\n      num = num.charCodeAt(0);\n    }\n    return num.toString(16);\n  };\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}