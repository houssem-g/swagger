{"ast":null,"code":"\"use strict\";\n\nvar get = require(\"lodash.get\");\nvar Errors = require(\"./Errors\");\nvar Utils = require(\"./Utils\");\n\n/**\n * @class\n *\n * @param {Report|object} parentOrOptions\n * @param {object} [reportOptions]\n */\nfunction Report(parentOrOptions, reportOptions) {\n  this.parentReport = parentOrOptions instanceof Report ? parentOrOptions : undefined;\n  this.options = parentOrOptions instanceof Report ? parentOrOptions.options : parentOrOptions || {};\n  this.reportOptions = reportOptions || {};\n  this.errors = [];\n  /**\n   * @type {string[]}\n   */\n  this.path = [];\n  this.asyncTasks = [];\n  this.rootSchema = undefined;\n  this.commonErrorMessage = undefined;\n  this.json = undefined;\n}\n\n/**\n * @returns {boolean}\n */\nReport.prototype.isValid = function () {\n  if (this.asyncTasks.length > 0) {\n    throw new Error(\"Async tasks pending, can't answer isValid\");\n  }\n  return this.errors.length === 0;\n};\n\n/**\n *\n * @param {*} fn\n * @param {*} args\n * @param {*} asyncTaskResultProcessFn\n */\nReport.prototype.addAsyncTask = function (fn, args, asyncTaskResultProcessFn) {\n  this.asyncTasks.push([fn, args, asyncTaskResultProcessFn]);\n};\nReport.prototype.getAncestor = function (id) {\n  if (!this.parentReport) {\n    return undefined;\n  }\n  if (this.parentReport.getSchemaId() === id) {\n    return this.parentReport;\n  }\n  return this.parentReport.getAncestor(id);\n};\n\n/**\n *\n * @param {*} timeout\n * @param {function(*, *)} callback\n *\n * @returns {void}\n */\nReport.prototype.processAsyncTasks = function (timeout, callback) {\n  var validationTimeout = timeout || 2000,\n    tasksCount = this.asyncTasks.length,\n    idx = tasksCount,\n    timedOut = false,\n    self = this;\n  function finish() {\n    process.nextTick(function () {\n      var valid = self.errors.length === 0,\n        err = valid ? null : self.errors;\n      callback(err, valid);\n    });\n  }\n  function respond(asyncTaskResultProcessFn) {\n    return function (asyncTaskResult) {\n      if (timedOut) {\n        return;\n      }\n      asyncTaskResultProcessFn(asyncTaskResult);\n      if (--tasksCount === 0) {\n        finish();\n      }\n    };\n  }\n\n  // finish if tasks are completed or there are any errors and breaking on first error was requested\n  if (tasksCount === 0 || this.errors.length > 0 && this.options.breakOnFirstError) {\n    finish();\n    return;\n  }\n  while (idx--) {\n    var task = this.asyncTasks[idx];\n    task[0].apply(null, task[1].concat(respond(task[2])));\n  }\n  setTimeout(function () {\n    if (tasksCount > 0) {\n      timedOut = true;\n      self.addError(\"ASYNC_TIMEOUT\", [tasksCount, validationTimeout]);\n      callback(self.errors, false);\n    }\n  }, validationTimeout);\n};\n\n/**\n *\n * @param {*} returnPathAsString\n *\n * @return {string[]|string}\n */\nReport.prototype.getPath = function (returnPathAsString) {\n  /**\n   * @type {string[]|string}\n   */\n  var path = [];\n  if (this.parentReport) {\n    path = path.concat(this.parentReport.path);\n  }\n  path = path.concat(this.path);\n  if (returnPathAsString !== true) {\n    // Sanitize the path segments (http://tools.ietf.org/html/rfc6901#section-4)\n    path = \"#/\" + path.map(function (segment) {\n      segment = segment.toString();\n      if (Utils.isAbsoluteUri(segment)) {\n        return \"uri(\" + segment + \")\";\n      }\n      return segment.replace(/\\~/g, \"~0\").replace(/\\//g, \"~1\");\n    }).join(\"/\");\n  }\n  return path;\n};\nReport.prototype.getSchemaId = function () {\n  if (!this.rootSchema) {\n    return null;\n  }\n\n  // get the error path as an array\n  var path = [];\n  if (this.parentReport) {\n    path = path.concat(this.parentReport.path);\n  }\n  path = path.concat(this.path);\n\n  // try to find id in the error path\n  while (path.length > 0) {\n    var obj = get(this.rootSchema, path);\n    if (obj && obj.id) {\n      return obj.id;\n    }\n    path.pop();\n  }\n\n  // return id of the root\n  return this.rootSchema.id;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} params\n *\n * @return {boolean}\n */\nReport.prototype.hasError = function (errorCode, params) {\n  var idx = this.errors.length;\n  while (idx--) {\n    if (this.errors[idx].code === errorCode) {\n      // assume match\n      var match = true;\n\n      // check the params too\n      var idx2 = this.errors[idx].params.length;\n      while (idx2--) {\n        if (this.errors[idx].params[idx2] !== params[idx2]) {\n          match = false;\n        }\n      }\n\n      // if match, return true\n      if (match) {\n        return match;\n      }\n    }\n  }\n  return false;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} params\n * @param {Report[]|Report} [subReports]\n * @param {*} [schema]\n *\n * @return {void}\n */\nReport.prototype.addError = function (errorCode, params, subReports, schema) {\n  if (!errorCode) {\n    throw new Error(\"No errorCode passed into addError()\");\n  }\n  this.addCustomError(errorCode, Errors[errorCode], params, subReports, schema);\n};\nReport.prototype.getJson = function () {\n  var self = this;\n  while (self.json === undefined) {\n    self = self.parentReport;\n    if (self === undefined) {\n      return undefined;\n    }\n  }\n  return self.json;\n};\n\n/**\n *\n * @param {*} errorCode\n * @param {*} errorMessage\n * @param {*[]} params\n * @param {Report[]|Report} subReports\n * @param {*} schema\n *\n * @returns {void}\n */\nReport.prototype.addCustomError = function (errorCode, errorMessage, params, subReports, schema) {\n  if (this.errors.length >= this.reportOptions.maxErrors) {\n    return;\n  }\n  if (!errorMessage) {\n    throw new Error(\"No errorMessage known for code \" + errorCode);\n  }\n  params = params || [];\n  var idx = params.length;\n  while (idx--) {\n    var whatIs = Utils.whatIs(params[idx]);\n    var param = whatIs === \"object\" || whatIs === \"null\" ? JSON.stringify(params[idx]) : params[idx];\n    errorMessage = errorMessage.replace(\"{\" + idx + \"}\", param);\n  }\n  var err = {\n    code: errorCode,\n    params: params,\n    message: errorMessage,\n    path: this.getPath(this.options.reportPathAsArray),\n    schemaId: this.getSchemaId()\n  };\n  err[Utils.schemaSymbol] = schema;\n  err[Utils.jsonSymbol] = this.getJson();\n  if (schema && typeof schema === \"string\") {\n    err.description = schema;\n  } else if (schema && typeof schema === \"object\") {\n    if (schema.title) {\n      err.title = schema.title;\n    }\n    if (schema.description) {\n      err.description = schema.description;\n    }\n  }\n  if (subReports != null) {\n    if (!Array.isArray(subReports)) {\n      subReports = [subReports];\n    }\n    err.inner = [];\n    idx = subReports.length;\n    while (idx--) {\n      var subReport = subReports[idx],\n        idx2 = subReport.errors.length;\n      while (idx2--) {\n        err.inner.push(subReport.errors[idx2]);\n      }\n    }\n    if (err.inner.length === 0) {\n      err.inner = undefined;\n    }\n  }\n  this.errors.push(err);\n};\nmodule.exports = Report;","map":null,"metadata":{},"sourceType":"script"}