{"ast":null,"code":"import { Ono as OnoConstructor } from \"./constructor\";\nconst singleton = ono;\nexport { singleton as ono };\nono.error = new OnoConstructor(Error);\nono.eval = new OnoConstructor(EvalError);\nono.range = new OnoConstructor(RangeError);\nono.reference = new OnoConstructor(ReferenceError);\nono.syntax = new OnoConstructor(SyntaxError);\nono.type = new OnoConstructor(TypeError);\nono.uri = new OnoConstructor(URIError);\nconst onoMap = ono;\n/**\n * Creates a new error with the specified message, properties, and/or inner error.\n * If an inner error is provided, then the new error will match its type, if possible.\n */\nfunction ono() {\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  let originalError = args[0];\n  // Is the first argument an Error-like object?\n  if (typeof originalError === \"object\" && typeof originalError.name === \"string\") {\n    // Try to find an Ono singleton method that matches this error type\n    for (let typedOno of Object.values(onoMap)) {\n      if (typeof typedOno === \"function\" && typedOno.name === \"ono\") {\n        let species = typedOno[Symbol.species];\n        if (species && species !== Error && (originalError instanceof species || originalError.name === species.name)) {\n          // Create an error of the same type\n          return typedOno.apply(undefined, args);\n        }\n      }\n    }\n  }\n  // By default, create a base Error object\n  return ono.error.apply(undefined, args);\n}","map":null,"metadata":{},"sourceType":"module"}