{"ast":null,"code":"\"use strict\";\n\nvar isequal = require(\"lodash.isequal\");\nvar Report = require(\"./Report\");\nvar SchemaCompilation = require(\"./SchemaCompilation\");\nvar SchemaValidation = require(\"./SchemaValidation\");\nvar Utils = require(\"./Utils\");\nfunction decodeJSONPointer(str) {\n  // http://tools.ietf.org/html/draft-ietf-appsawg-json-pointer-07#section-3\n  return decodeURIComponent(str).replace(/~[0-1]/g, function (x) {\n    return x === \"~1\" ? \"/\" : \"~\";\n  });\n}\nfunction getRemotePath(uri) {\n  var io = uri.indexOf(\"#\");\n  return io === -1 ? uri : uri.slice(0, io);\n}\nfunction getQueryPath(uri) {\n  var io = uri.indexOf(\"#\");\n  var res = io === -1 ? undefined : uri.slice(io + 1);\n  // WARN: do not slice slash, #/ means take root and go down from it\n  // if (res && res[0] === \"/\") { res = res.slice(1); }\n  return res;\n}\nfunction findId(schema, id) {\n  // process only arrays and objects\n  if (typeof schema !== \"object\" || schema === null) {\n    return;\n  }\n\n  // no id means root so return itself\n  if (!id) {\n    return schema;\n  }\n  if (schema.id) {\n    if (schema.id === id || schema.id[0] === \"#\" && schema.id.substring(1) === id) {\n      return schema;\n    }\n  }\n  var idx, result;\n  if (Array.isArray(schema)) {\n    idx = schema.length;\n    while (idx--) {\n      result = findId(schema[idx], id);\n      if (result) {\n        return result;\n      }\n    }\n  } else {\n    var keys = Object.keys(schema);\n    idx = keys.length;\n    while (idx--) {\n      var k = keys[idx];\n      if (k.indexOf(\"__$\") === 0) {\n        continue;\n      }\n      result = findId(schema[k], id);\n      if (result) {\n        return result;\n      }\n    }\n  }\n}\n\n/**\n *\n * @param {*} uri\n * @param {*} schema\n *\n * @returns {void}\n */\nexports.cacheSchemaByUri = function (uri, schema) {\n  var remotePath = getRemotePath(uri);\n  if (remotePath) {\n    this.cache[remotePath] = schema;\n  }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {void}\n */\nexports.removeFromCacheByUri = function (uri) {\n  var remotePath = getRemotePath(uri);\n  if (remotePath) {\n    delete this.cache[remotePath];\n  }\n};\n\n/**\n *\n * @param {*} uri\n *\n * @returns {boolean}\n */\nexports.checkCacheForUri = function (uri) {\n  var remotePath = getRemotePath(uri);\n  return remotePath ? this.cache[remotePath] != null : false;\n};\nexports.getSchema = function (report, schema) {\n  if (typeof schema === \"object\") {\n    schema = exports.getSchemaByReference.call(this, report, schema);\n  }\n  if (typeof schema === \"string\") {\n    schema = exports.getSchemaByUri.call(this, report, schema);\n  }\n  return schema;\n};\nexports.getSchemaByReference = function (report, key) {\n  var i = this.referenceCache.length;\n  while (i--) {\n    if (isequal(this.referenceCache[i][0], key)) {\n      return this.referenceCache[i][1];\n    }\n  }\n  // not found\n  var schema = Utils.cloneDeep(key);\n  this.referenceCache.push([key, schema]);\n  return schema;\n};\nexports.getSchemaByUri = function (report, uri, root) {\n  var remotePath = getRemotePath(uri),\n    queryPath = getQueryPath(uri),\n    result = remotePath ? this.cache[remotePath] : root;\n  if (result && remotePath) {\n    // we need to avoid compiling schemas in a recursive loop\n    var compileRemote = result !== root;\n    // now we need to compile and validate resolved schema (in case it's not already)\n    if (compileRemote) {\n      report.path.push(remotePath);\n      var remoteReport;\n      var anscestorReport = report.getAncestor(result.id);\n      if (anscestorReport) {\n        remoteReport = anscestorReport;\n      } else {\n        remoteReport = new Report(report);\n        if (SchemaCompilation.compileSchema.call(this, remoteReport, result)) {\n          var savedOptions = this.options;\n          try {\n            // If custom validationOptions were provided to setRemoteReference(),\n            // use them instead of the default options\n            this.options = result.__$validationOptions || this.options;\n            SchemaValidation.validateSchema.call(this, remoteReport, result);\n          } finally {\n            this.options = savedOptions;\n          }\n        }\n      }\n      var remoteReportIsValid = remoteReport.isValid();\n      if (!remoteReportIsValid) {\n        report.addError(\"REMOTE_NOT_VALID\", [uri], remoteReport);\n      }\n      report.path.pop();\n      if (!remoteReportIsValid) {\n        return undefined;\n      }\n    }\n  }\n  if (result && queryPath) {\n    var parts = queryPath.split(\"/\");\n    for (var idx = 0, lim = parts.length; result && idx < lim; idx++) {\n      var key = decodeJSONPointer(parts[idx]);\n      if (idx === 0) {\n        // it's an id\n        result = findId(result, key);\n      } else {\n        // it's a path behind id\n        result = result[key];\n      }\n    }\n  }\n  return result;\n};\nexports.getRemotePath = getRemotePath;","map":null,"metadata":{},"sourceType":"script"}