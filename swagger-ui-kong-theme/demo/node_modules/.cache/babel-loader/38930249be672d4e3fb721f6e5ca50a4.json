{"ast":null,"code":"\"use strict\";\n\nvar FormatValidators = require(\"./FormatValidators\"),\n  Report = require(\"./Report\"),\n  Utils = require(\"./Utils\");\nvar shouldSkipValidate = function (options, errors) {\n  return options && Array.isArray(options.includeErrors) && options.includeErrors.length > 0 && !errors.some(function (err) {\n    return options.includeErrors.includes(err);\n  });\n};\nvar JsonValidators = {\n  multipleOf: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.1.2\n    if (shouldSkipValidate(this.validateOptions, [\"MULTIPLE_OF\"])) {\n      return;\n    }\n    if (typeof json !== \"number\") {\n      return;\n    }\n    var stringMultipleOf = String(schema.multipleOf);\n    var scale = Math.pow(10, stringMultipleOf.length - stringMultipleOf.indexOf(\".\") - 1);\n    if (Utils.whatIs(json * scale / (schema.multipleOf * scale)) !== \"integer\") {\n      report.addError(\"MULTIPLE_OF\", [json, schema.multipleOf], null, schema);\n    }\n  },\n  maximum: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.2.2\n    if (shouldSkipValidate(this.validateOptions, [\"MAXIMUM\", \"MAXIMUM_EXCLUSIVE\"])) {\n      return;\n    }\n    if (typeof json !== \"number\") {\n      return;\n    }\n    if (schema.exclusiveMaximum !== true) {\n      if (json > schema.maximum) {\n        report.addError(\"MAXIMUM\", [json, schema.maximum], null, schema);\n      }\n    } else {\n      if (json >= schema.maximum) {\n        report.addError(\"MAXIMUM_EXCLUSIVE\", [json, schema.maximum], null, schema);\n      }\n    }\n  },\n  exclusiveMaximum: function () {\n    // covered in maximum\n  },\n  minimum: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.1.3.2\n    if (shouldSkipValidate(this.validateOptions, [\"MINIMUM\", \"MINIMUM_EXCLUSIVE\"])) {\n      return;\n    }\n    if (typeof json !== \"number\") {\n      return;\n    }\n    if (schema.exclusiveMinimum !== true) {\n      if (json < schema.minimum) {\n        report.addError(\"MINIMUM\", [json, schema.minimum], null, schema);\n      }\n    } else {\n      if (json <= schema.minimum) {\n        report.addError(\"MINIMUM_EXCLUSIVE\", [json, schema.minimum], null, schema);\n      }\n    }\n  },\n  exclusiveMinimum: function () {\n    // covered in minimum\n  },\n  maxLength: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.1.2\n    if (shouldSkipValidate(this.validateOptions, [\"MAX_LENGTH\"])) {\n      return;\n    }\n    if (typeof json !== \"string\") {\n      return;\n    }\n    if (Utils.ucs2decode(json).length > schema.maxLength) {\n      report.addError(\"MAX_LENGTH\", [json.length, schema.maxLength], null, schema);\n    }\n  },\n  minLength: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.2.2\n    if (shouldSkipValidate(this.validateOptions, [\"MIN_LENGTH\"])) {\n      return;\n    }\n    if (typeof json !== \"string\") {\n      return;\n    }\n    if (Utils.ucs2decode(json).length < schema.minLength) {\n      report.addError(\"MIN_LENGTH\", [json.length, schema.minLength], null, schema);\n    }\n  },\n  pattern: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.2.3.2\n    if (shouldSkipValidate(this.validateOptions, [\"PATTERN\"])) {\n      return;\n    }\n    if (typeof json !== \"string\") {\n      return;\n    }\n    if (RegExp(schema.pattern).test(json) === false) {\n      report.addError(\"PATTERN\", [schema.pattern, json], null, schema);\n    }\n  },\n  additionalItems: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.1.2\n    if (shouldSkipValidate(this.validateOptions, [\"ARRAY_ADDITIONAL_ITEMS\"])) {\n      return;\n    }\n    if (!Array.isArray(json)) {\n      return;\n    }\n    // if the value of \"additionalItems\" is boolean value false and the value of \"items\" is an array,\n    // the json is valid if its size is less than, or equal to, the size of \"items\".\n    if (schema.additionalItems === false && Array.isArray(schema.items)) {\n      if (json.length > schema.items.length) {\n        report.addError(\"ARRAY_ADDITIONAL_ITEMS\", null, null, schema);\n      }\n    }\n  },\n  items: function () {/*report, schema, json*/\n    // covered in additionalItems\n  },\n  maxItems: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.2.2\n    if (shouldSkipValidate(this.validateOptions, [\"ARRAY_LENGTH_LONG\"])) {\n      return;\n    }\n    if (!Array.isArray(json)) {\n      return;\n    }\n    if (json.length > schema.maxItems) {\n      report.addError(\"ARRAY_LENGTH_LONG\", [json.length, schema.maxItems], null, schema);\n    }\n  },\n  minItems: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.3.2\n    if (shouldSkipValidate(this.validateOptions, [\"ARRAY_LENGTH_SHORT\"])) {\n      return;\n    }\n    if (!Array.isArray(json)) {\n      return;\n    }\n    if (json.length < schema.minItems) {\n      report.addError(\"ARRAY_LENGTH_SHORT\", [json.length, schema.minItems], null, schema);\n    }\n  },\n  uniqueItems: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.3.4.2\n    if (shouldSkipValidate(this.validateOptions, [\"ARRAY_UNIQUE\"])) {\n      return;\n    }\n    if (!Array.isArray(json)) {\n      return;\n    }\n    if (schema.uniqueItems === true) {\n      var matches = [];\n      if (Utils.isUniqueArray(json, matches) === false) {\n        report.addError(\"ARRAY_UNIQUE\", matches, null, schema);\n      }\n    }\n  },\n  maxProperties: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.1.2\n    if (shouldSkipValidate(this.validateOptions, [\"OBJECT_PROPERTIES_MAXIMUM\"])) {\n      return;\n    }\n    if (Utils.whatIs(json) !== \"object\") {\n      return;\n    }\n    var keysCount = Object.keys(json).length;\n    if (keysCount > schema.maxProperties) {\n      report.addError(\"OBJECT_PROPERTIES_MAXIMUM\", [keysCount, schema.maxProperties], null, schema);\n    }\n  },\n  minProperties: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.2.2\n    if (shouldSkipValidate(this.validateOptions, [\"OBJECT_PROPERTIES_MINIMUM\"])) {\n      return;\n    }\n    if (Utils.whatIs(json) !== \"object\") {\n      return;\n    }\n    var keysCount = Object.keys(json).length;\n    if (keysCount < schema.minProperties) {\n      report.addError(\"OBJECT_PROPERTIES_MINIMUM\", [keysCount, schema.minProperties], null, schema);\n    }\n  },\n  required: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.3.2\n    if (shouldSkipValidate(this.validateOptions, [\"OBJECT_MISSING_REQUIRED_PROPERTY\"])) {\n      return;\n    }\n    if (Utils.whatIs(json) !== \"object\") {\n      return;\n    }\n    var idx = schema.required.length;\n    while (idx--) {\n      var requiredPropertyName = schema.required[idx];\n      if (json[requiredPropertyName] === undefined) {\n        report.addError(\"OBJECT_MISSING_REQUIRED_PROPERTY\", [requiredPropertyName], null, schema);\n      }\n    }\n  },\n  additionalProperties: function (report, schema, json) {\n    // covered in properties and patternProperties\n    if (schema.properties === undefined && schema.patternProperties === undefined) {\n      return JsonValidators.properties.call(this, report, schema, json);\n    }\n  },\n  patternProperties: function (report, schema, json) {\n    // covered in properties\n    if (schema.properties === undefined) {\n      return JsonValidators.properties.call(this, report, schema, json);\n    }\n  },\n  properties: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.4.2\n    if (shouldSkipValidate(this.validateOptions, [\"OBJECT_ADDITIONAL_PROPERTIES\"])) {\n      return;\n    }\n    if (Utils.whatIs(json) !== \"object\") {\n      return;\n    }\n    var properties = schema.properties !== undefined ? schema.properties : {};\n    var patternProperties = schema.patternProperties !== undefined ? schema.patternProperties : {};\n    if (schema.additionalProperties === false) {\n      // The property set of the json to validate.\n      var s = Object.keys(json);\n      // The property set from \"properties\".\n      var p = Object.keys(properties);\n      // The property set from \"patternProperties\".\n      var pp = Object.keys(patternProperties);\n      // remove from \"s\" all elements of \"p\", if any;\n      s = Utils.difference(s, p);\n      // for each regex in \"pp\", remove all elements of \"s\" which this regex matches.\n      var idx = pp.length;\n      while (idx--) {\n        var regExp = RegExp(pp[idx]),\n          idx2 = s.length;\n        while (idx2--) {\n          if (regExp.test(s[idx2]) === true) {\n            s.splice(idx2, 1);\n          }\n        }\n      }\n      // Validation of the json succeeds if, after these two steps, set \"s\" is empty.\n      if (s.length > 0) {\n        // assumeAdditional can be an array of allowed properties\n        var idx3 = this.options.assumeAdditional.length;\n        if (idx3) {\n          while (idx3--) {\n            var io = s.indexOf(this.options.assumeAdditional[idx3]);\n            if (io !== -1) {\n              s.splice(io, 1);\n            }\n          }\n        }\n        var idx4 = s.length;\n        if (idx4) {\n          while (idx4--) {\n            report.addError(\"OBJECT_ADDITIONAL_PROPERTIES\", [s[idx4]], null, schema);\n          }\n        }\n      }\n    }\n  },\n  dependencies: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.4.5.2\n    if (shouldSkipValidate(this.validateOptions, [\"OBJECT_DEPENDENCY_KEY\"])) {\n      return;\n    }\n    if (Utils.whatIs(json) !== \"object\") {\n      return;\n    }\n    var keys = Object.keys(schema.dependencies),\n      idx = keys.length;\n    while (idx--) {\n      // iterate all dependencies\n      var dependencyName = keys[idx];\n      if (json[dependencyName]) {\n        var dependencyDefinition = schema.dependencies[dependencyName];\n        if (Utils.whatIs(dependencyDefinition) === \"object\") {\n          // if dependency is a schema, validate against this schema\n          exports.validate.call(this, report, dependencyDefinition, json);\n        } else {\n          // Array\n          // if dependency is an array, object needs to have all properties in this array\n          var idx2 = dependencyDefinition.length;\n          while (idx2--) {\n            var requiredPropertyName = dependencyDefinition[idx2];\n            if (json[requiredPropertyName] === undefined) {\n              report.addError(\"OBJECT_DEPENDENCY_KEY\", [requiredPropertyName, dependencyName], null, schema);\n            }\n          }\n        }\n      }\n    }\n  },\n  enum: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.1.2\n    if (shouldSkipValidate(this.validateOptions, [\"ENUM_CASE_MISMATCH\", \"ENUM_MISMATCH\"])) {\n      return;\n    }\n    var match = false,\n      caseInsensitiveMatch = false,\n      idx = schema.enum.length;\n    while (idx--) {\n      if (Utils.areEqual(json, schema.enum[idx])) {\n        match = true;\n        break;\n      } else if (Utils.areEqual(json, schema.enum[idx]), {\n        caseInsensitiveComparison: true\n      }) {\n        caseInsensitiveMatch = true;\n      }\n    }\n    if (match === false) {\n      var error = caseInsensitiveMatch && this.options.enumCaseInsensitiveComparison ? \"ENUM_CASE_MISMATCH\" : \"ENUM_MISMATCH\";\n      report.addError(error, [json], null, schema);\n    }\n  },\n  type: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.2.2\n    if (shouldSkipValidate(this.validateOptions, [\"INVALID_TYPE\"])) {\n      return;\n    }\n    var jsonType = Utils.whatIs(json);\n    if (typeof schema.type === \"string\") {\n      if (jsonType !== schema.type && (jsonType !== \"integer\" || schema.type !== \"number\")) {\n        report.addError(\"INVALID_TYPE\", [schema.type, jsonType], null, schema);\n      }\n    } else {\n      if (schema.type.indexOf(jsonType) === -1 && (jsonType !== \"integer\" || schema.type.indexOf(\"number\") === -1)) {\n        report.addError(\"INVALID_TYPE\", [schema.type, jsonType], null, schema);\n      }\n    }\n  },\n  allOf: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.3.2\n    var idx = schema.allOf.length;\n    while (idx--) {\n      var validateResult = exports.validate.call(this, report, schema.allOf[idx], json);\n      if (this.options.breakOnFirstError && validateResult === false) {\n        break;\n      }\n    }\n  },\n  anyOf: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.4.2\n    var subReports = [],\n      passed = false,\n      idx = schema.anyOf.length;\n    while (idx-- && passed === false) {\n      var subReport = new Report(report);\n      subReports.push(subReport);\n      passed = exports.validate.call(this, subReport, schema.anyOf[idx], json);\n    }\n    if (passed === false) {\n      report.addError(\"ANY_OF_MISSING\", undefined, subReports, schema);\n    }\n  },\n  oneOf: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.5.2\n    var passes = 0,\n      subReports = [],\n      idx = schema.oneOf.length;\n    while (idx--) {\n      var subReport = new Report(report, {\n        maxErrors: 1\n      });\n      subReports.push(subReport);\n      if (exports.validate.call(this, subReport, schema.oneOf[idx], json) === true) {\n        passes++;\n      }\n    }\n    if (passes === 0) {\n      report.addError(\"ONE_OF_MISSING\", undefined, subReports, schema);\n    } else if (passes > 1) {\n      report.addError(\"ONE_OF_MULTIPLE\", null, null, schema);\n    }\n  },\n  not: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.6.2\n    var subReport = new Report(report);\n    if (exports.validate.call(this, subReport, schema.not, json) === true) {\n      report.addError(\"NOT_PASSED\", null, null, schema);\n    }\n  },\n  definitions: function () {/*report, schema, json*/\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.5.5.7.2\n    // nothing to do here\n  },\n  format: function (report, schema, json) {\n    // http://json-schema.org/latest/json-schema-validation.html#rfc.section.7.2\n    var formatValidatorFn = FormatValidators[schema.format];\n    if (typeof formatValidatorFn === \"function\") {\n      if (shouldSkipValidate(this.validateOptions, [\"INVALID_FORMAT\"])) {\n        return;\n      }\n      if (formatValidatorFn.length === 2) {\n        // async - need to clone the path here, because it will change by the time async function reports back\n        var pathBeforeAsync = Utils.clone(report.path);\n        report.addAsyncTask(formatValidatorFn, [json], function (result) {\n          if (result !== true) {\n            var backup = report.path;\n            report.path = pathBeforeAsync;\n            report.addError(\"INVALID_FORMAT\", [schema.format, json], null, schema);\n            report.path = backup;\n          }\n        });\n      } else {\n        // sync\n        if (formatValidatorFn.call(this, json) !== true) {\n          report.addError(\"INVALID_FORMAT\", [schema.format, json], null, schema);\n        }\n      }\n    } else if (this.options.ignoreUnknownFormats !== true) {\n      report.addError(\"UNKNOWN_FORMAT\", [schema.format], null, schema);\n    }\n  }\n};\nvar recurseArray = function (report, schema, json) {\n  // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.2\n\n  var idx = json.length;\n\n  // If \"items\" is an array, this situation, the schema depends on the index:\n  // if the index is less than, or equal to, the size of \"items\",\n  // the child instance must be valid against the corresponding schema in the \"items\" array;\n  // otherwise, it must be valid against the schema defined by \"additionalItems\".\n  if (Array.isArray(schema.items)) {\n    while (idx--) {\n      // equal to doesn't make sense here\n      if (idx < schema.items.length) {\n        report.path.push(idx);\n        exports.validate.call(this, report, schema.items[idx], json[idx]);\n        report.path.pop();\n      } else {\n        // might be boolean, so check that it's an object\n        if (typeof schema.additionalItems === \"object\") {\n          report.path.push(idx);\n          exports.validate.call(this, report, schema.additionalItems, json[idx]);\n          report.path.pop();\n        }\n      }\n    }\n  } else if (typeof schema.items === \"object\") {\n    // If items is a schema, then the child instance must be valid against this schema,\n    // regardless of its index, and regardless of the value of \"additionalItems\".\n    while (idx--) {\n      report.path.push(idx);\n      exports.validate.call(this, report, schema.items, json[idx]);\n      report.path.pop();\n    }\n  }\n};\nvar recurseObject = function (report, schema, json) {\n  // http://json-schema.org/latest/json-schema-validation.html#rfc.section.8.3\n\n  // If \"additionalProperties\" is absent, it is considered present with an empty schema as a value.\n  // In addition, boolean value true is considered equivalent to an empty schema.\n  var additionalProperties = schema.additionalProperties;\n  if (additionalProperties === true || additionalProperties === undefined) {\n    additionalProperties = {};\n  }\n\n  // p - The property set from \"properties\".\n  var p = schema.properties ? Object.keys(schema.properties) : [];\n\n  // pp - The property set from \"patternProperties\". Elements of this set will be called regexes for convenience.\n  var pp = schema.patternProperties ? Object.keys(schema.patternProperties) : [];\n\n  // m - The property name of the child.\n  var keys = Object.keys(json),\n    idx = keys.length;\n  while (idx--) {\n    var m = keys[idx],\n      propertyValue = json[m];\n\n    // s - The set of schemas for the child instance.\n    var s = [];\n\n    // 1. If set \"p\" contains value \"m\", then the corresponding schema in \"properties\" is added to \"s\".\n    if (p.indexOf(m) !== -1) {\n      s.push(schema.properties[m]);\n    }\n\n    // 2. For each regex in \"pp\", if it matches \"m\" successfully, the corresponding schema in \"patternProperties\" is added to \"s\".\n    var idx2 = pp.length;\n    while (idx2--) {\n      var regexString = pp[idx2];\n      if (RegExp(regexString).test(m) === true) {\n        s.push(schema.patternProperties[regexString]);\n      }\n    }\n\n    // 3. The schema defined by \"additionalProperties\" is added to \"s\" if and only if, at this stage, \"s\" is empty.\n    if (s.length === 0 && additionalProperties !== false) {\n      s.push(additionalProperties);\n    }\n\n    // we are passing tests even without this assert because this is covered by properties check\n    // if s is empty in this stage, no additionalProperties are allowed\n    // report.expect(s.length !== 0, 'E001', m);\n\n    // Instance property value must pass all schemas from s\n    idx2 = s.length;\n    while (idx2--) {\n      report.path.push(m);\n      exports.validate.call(this, report, s[idx2], propertyValue);\n      report.path.pop();\n    }\n  }\n};\nexports.JsonValidators = JsonValidators;\n\n/**\n *\n * @param {Report} report\n * @param {*} schema\n * @param {*} json\n */\nexports.validate = function (report, schema, json) {\n  report.commonErrorMessage = \"JSON_OBJECT_VALIDATION_FAILED\";\n\n  // check if schema is an object\n  var to = Utils.whatIs(schema);\n  if (to !== \"object\") {\n    report.addError(\"SCHEMA_NOT_AN_OBJECT\", [to], null, schema);\n    return false;\n  }\n\n  // check if schema is empty, everything is valid against empty schema\n  var keys = Object.keys(schema);\n  if (keys.length === 0) {\n    return true;\n  }\n\n  // this method can be called recursively, so we need to remember our root\n  var isRoot = false;\n  if (!report.rootSchema) {\n    report.rootSchema = schema;\n    isRoot = true;\n  }\n\n  // follow schema.$ref keys\n  if (schema.$ref !== undefined) {\n    // avoid infinite loop with maxRefs\n    var maxRefs = 99;\n    while (schema.$ref && maxRefs > 0) {\n      if (!schema.__$refResolved) {\n        report.addError(\"REF_UNRESOLVED\", [schema.$ref], null, schema);\n        break;\n      } else if (schema.__$refResolved === schema) {\n        break;\n      } else {\n        schema = schema.__$refResolved;\n        keys = Object.keys(schema);\n      }\n      maxRefs--;\n    }\n    if (maxRefs === 0) {\n      throw new Error(\"Circular dependency by $ref references!\");\n    }\n  }\n\n  // type checking first\n  var jsonType = Utils.whatIs(json);\n  if (schema.type) {\n    keys.splice(keys.indexOf(\"type\"), 1);\n    JsonValidators.type.call(this, report, schema, json);\n    if (report.errors.length && this.options.breakOnFirstError) {\n      return false;\n    }\n  }\n\n  // now iterate all the keys in schema and execute validation methods\n  var idx = keys.length;\n  while (idx--) {\n    if (JsonValidators[keys[idx]]) {\n      JsonValidators[keys[idx]].call(this, report, schema, json);\n      if (report.errors.length && this.options.breakOnFirstError) {\n        break;\n      }\n    }\n  }\n  if (report.errors.length === 0 || this.options.breakOnFirstError === false) {\n    if (jsonType === \"array\") {\n      recurseArray.call(this, report, schema, json);\n    } else if (jsonType === \"object\") {\n      recurseObject.call(this, report, schema, json);\n    }\n  }\n  if (typeof this.options.customValidator === \"function\") {\n    this.options.customValidator.call(this, report, schema, json);\n  }\n\n  // we don't need the root pointer anymore\n  if (isRoot) {\n    report.rootSchema = undefined;\n  }\n\n  // return valid just to be able to break at some code points\n  return report.errors.length === 0;\n};","map":null,"metadata":{},"sourceType":"script"}