{"ast":null,"code":"import { addInspectMethod } from \"./isomorphic.node\";\nimport { isLazyStack, isWritableStack, joinStacks, lazyJoinStacks } from \"./stack\";\nimport { getDeepKeys, toJSON } from \"./to-json\";\nconst protectedProps = [\"name\", \"message\", \"stack\"];\n/**\n * Extends the new error with the properties of the original error and the `props` object.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n * @param props - Additional properties to add, if any\n */\nexport function extendError(newError, originalError, props) {\n  extendStack(newError, originalError);\n  // Copy properties from the original error\n  if (originalError && typeof originalError === \"object\") {\n    mergeErrors(newError, originalError);\n  }\n  // The default `toJSON` method doesn't output props like `name`, `message`, `stack`, etc.\n  // So replace it with one that outputs every property of the error.\n  newError.toJSON = toJSON;\n  // On Node.js, add support for the `util.inspect()` method\n  if (addInspectMethod) {\n    addInspectMethod(newError);\n  }\n  // Finally, copy custom properties that were specified by the user.\n  // These props OVERWRITE any previous props\n  if (props && typeof props === \"object\") {\n    Object.assign(newError, props);\n  }\n}\n/**\n * Extend the error stack to include its cause\n */\nfunction extendStack(newError, originalError) {\n  let stackProp = Object.getOwnPropertyDescriptor(newError, \"stack\");\n  if (isLazyStack(stackProp)) {\n    lazyJoinStacks(stackProp, newError, originalError);\n  } else if (isWritableStack(stackProp)) {\n    newError.stack = joinStacks(newError, originalError);\n  }\n}\n/**\n * Merges properties of the original error with the new error.\n *\n * @param newError - The error object to extend\n * @param originalError - The original error object, if any\n */\nfunction mergeErrors(newError, originalError) {\n  // Get the original error's keys\n  // NOTE: We specifically exclude properties that we have already set on the new error.\n  // This is _especially_ important for the `stack` property, because this property has\n  // a lazy getter in some environments\n  let keys = getDeepKeys(originalError, protectedProps);\n  // HACK: We have to cast the errors to `any` so we can use symbol indexers.\n  // see https://github.com/Microsoft/TypeScript/issues/1863\n  // tslint:disable: no-any no-unsafe-any\n  let _newError = newError;\n  let _originalError = originalError;\n  for (let key of keys) {\n    if (_newError[key] === undefined) {\n      try {\n        _newError[key] = _originalError[key];\n      } catch (e) {\n        // This property is read-only, so it can't be copied\n      }\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"module"}