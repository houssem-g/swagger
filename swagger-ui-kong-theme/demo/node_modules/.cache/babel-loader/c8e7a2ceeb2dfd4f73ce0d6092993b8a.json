{"ast":null,"code":"const newline = /\\r?\\n/;\nconst onoCall = /\\bono[ @]/;\n/**\n * Is the property lazily computed?\n */\nexport function isLazyStack(stackProp) {\n  return Boolean(stackProp && stackProp.configurable && typeof stackProp.get === \"function\");\n}\n/**\n * Is the stack property writable?\n */\nexport function isWritableStack(stackProp) {\n  return Boolean(\n  // If there is no stack property, then it's writable, since assigning it will create it\n  !stackProp || stackProp.writable || typeof stackProp.set === \"function\");\n}\n/**\n * Appends the original `Error.stack` property to the new Error's stack.\n */\nexport function joinStacks(newError, originalError) {\n  let newStack = popStack(newError.stack);\n  let originalStack = originalError ? originalError.stack : undefined;\n  if (newStack && originalStack) {\n    return newStack + \"\\n\\n\" + originalStack;\n  } else {\n    return newStack || originalStack;\n  }\n}\n/**\n * Calls `joinStacks` lazily, when the `Error.stack` property is accessed.\n */\nexport function lazyJoinStacks(lazyStack, newError, originalError) {\n  if (originalError) {\n    Object.defineProperty(newError, \"stack\", {\n      get: () => {\n        let newStack = lazyStack.get.apply(newError);\n        return joinStacks({\n          stack: newStack\n        }, originalError);\n      },\n      enumerable: false,\n      configurable: true\n    });\n  } else {\n    lazyPopStack(newError, lazyStack);\n  }\n}\n/**\n * Removes Ono from the stack, so that the stack starts at the original error location\n */\nfunction popStack(stack) {\n  if (stack) {\n    let lines = stack.split(newline);\n    // Find the Ono call(s) in the stack, and remove them\n    let onoStart;\n    for (let i = 0; i < lines.length; i++) {\n      let line = lines[i];\n      if (onoCall.test(line)) {\n        if (onoStart === undefined) {\n          // We found the first Ono call in the stack trace.\n          // There may be other subsequent Ono calls as well.\n          onoStart = i;\n        }\n      } else if (onoStart !== undefined) {\n        // We found the first non-Ono call after one or more Ono calls.\n        // So remove the Ono call lines from the stack trace\n        lines.splice(onoStart, i - onoStart);\n        break;\n      }\n    }\n    if (lines.length > 0) {\n      return lines.join(\"\\n\");\n    }\n  }\n  // If we get here, then the stack doesn't contain a call to `ono`.\n  // This may be due to minification or some optimization of the JS engine.\n  // So just return the stack as-is.\n  return stack;\n}\n/**\n * Calls `popStack` lazily, when the `Error.stack` property is accessed.\n */\nfunction lazyPopStack(error, lazyStack) {\n  Object.defineProperty(error, \"stack\", {\n    get: () => popStack(lazyStack.get.apply(error)),\n    enumerable: false,\n    configurable: true\n  });\n}","map":null,"metadata":{},"sourceType":"module"}