{"ast":null,"code":"(function () {\n  var ScalarAnalysis,\n    YAMLError,\n    events,\n    util,\n    extend = function (child, parent) {\n      for (var key in parent) {\n        if (hasProp.call(parent, key)) child[key] = parent[key];\n      }\n      function ctor() {\n        this.constructor = child;\n      }\n      ctor.prototype = parent.prototype;\n      child.prototype = new ctor();\n      child.__super__ = parent.prototype;\n      return child;\n    },\n    hasProp = {}.hasOwnProperty,\n    indexOf = [].indexOf || function (item) {\n      for (var i = 0, l = this.length; i < l; i++) {\n        if (i in this && this[i] === item) return i;\n      }\n      return -1;\n    };\n  events = require('./events');\n  util = require('./util');\n  YAMLError = require('./errors').YAMLError;\n  this.EmitterError = function (superClass) {\n    extend(EmitterError, superClass);\n    function EmitterError() {\n      return EmitterError.__super__.constructor.apply(this, arguments);\n    }\n    return EmitterError;\n  }(YAMLError);\n\n  /*\n  Emitter expects events obeying the following grammar:\n  \n  stream   ::= STREAM-START document* STREAM-END\n  document ::= DOCUMENT-START node DOCUMENT-END\n  node     ::= SCALA | sequence | mapping\n  sequence ::= SEQUENCE-START node* SEQUENCE-END\n  mapping  ::= MAPPING-START (node node)* MAPPING-END\n   */\n\n  this.Emitter = function () {\n    var C_WHITESPACE, DEFAULT_TAG_PREFIXES, ESCAPE_REPLACEMENTS;\n    C_WHITESPACE = '\\0 \\t\\r\\n\\x85\\u2028\\u2029';\n    DEFAULT_TAG_PREFIXES = {\n      '!': '!',\n      'tag:yaml.org,2002:': '!!'\n    };\n    ESCAPE_REPLACEMENTS = {\n      '\\0': '0',\n      '\\x07': 'a',\n      '\\x08': 'b',\n      '\\x09': 't',\n      '\\x0A': 'n',\n      '\\x0B': 'v',\n      '\\x0C': 'f',\n      '\\x0D': 'r',\n      '\\x1B': 'e',\n      '\"': '\"',\n      '\\\\': '\\\\',\n      '\\x85': 'N',\n      '\\xA0': '_',\n      '\\u2028': 'L',\n      '\\u2029': 'P'\n    };\n    function Emitter(stream, options) {\n      var ref;\n      this.stream = stream;\n      this.encoding = null;\n      this.states = [];\n      this.state = this.expect_stream_start;\n      this.events = [];\n      this.event = null;\n      this.indents = [];\n      this.indent = null;\n      this.flow_level = 0;\n      this.root_context = false;\n      this.sequence_context = false;\n      this.mapping_context = false;\n      this.simple_key_context = false;\n      this.line = 0;\n      this.column = 0;\n      this.whitespace = true;\n      this.indentation = true;\n      this.open_ended = false;\n      this.canonical = options.canonical, this.allow_unicode = options.allow_unicode;\n      if (this.canonical == null) {\n        this.canonical = false;\n      }\n      if (this.allow_unicode == null) {\n        this.allow_unicode = true;\n      }\n      this.best_indent = 1 < options.indent && options.indent < 10 ? options.indent : 2;\n      this.best_width = options.width > this.indent * 2 ? options.width : 80;\n      this.best_line_break = (ref = options.line_break) === '\\r' || ref === '\\n' || ref === '\\r\\n' ? options.line_break : '\\n';\n      this.tag_prefixes = null;\n      this.prepared_anchor = null;\n      this.prepared_tag = null;\n      this.analysis = null;\n      this.style = null;\n    }\n\n    /*\n    Reset the state attributes (to clear self-references)\n     */\n\n    Emitter.prototype.dispose = function () {\n      this.states = [];\n      return this.state = null;\n    };\n    Emitter.prototype.emit = function (event) {\n      var results;\n      this.events.push(event);\n      results = [];\n      while (!this.need_more_events()) {\n        this.event = this.events.shift();\n        this.state();\n        results.push(this.event = null);\n      }\n      return results;\n    };\n\n    /*\n    In some cases, we wait for a few next events before emitting.\n     */\n\n    Emitter.prototype.need_more_events = function () {\n      var event;\n      if (this.events.length === 0) {\n        return true;\n      }\n      event = this.events[0];\n      if (event instanceof events.DocumentStartEvent) {\n        return this.need_events(1);\n      } else if (event instanceof events.SequenceStartEvent) {\n        return this.need_events(2);\n      } else if (event instanceof events.MappingStartEvent) {\n        return this.need_events(3);\n      } else {\n        return false;\n      }\n    };\n    Emitter.prototype.need_events = function (count) {\n      var event, i, len, level, ref;\n      level = 0;\n      ref = this.events.slice(1);\n      for (i = 0, len = ref.length; i < len; i++) {\n        event = ref[i];\n        if (event instanceof events.DocumentStartEvent || event instanceof events.CollectionStartEvent) {\n          level++;\n        } else if (event instanceof events.DocumentEndEvent || event instanceof events.CollectionEndEvent) {\n          level--;\n        } else if (event instanceof events.StreamEndEvent) {\n          level = -1;\n        }\n        if (level < 0) {\n          return false;\n        }\n      }\n      return this.events.length < count + 1;\n    };\n    Emitter.prototype.increase_indent = function (options) {\n      if (options == null) {\n        options = {};\n      }\n      this.indents.push(this.indent);\n      if (this.indent == null) {\n        return this.indent = options.flow ? this.best_indent : 0;\n      } else if (!options.indentless) {\n        return this.indent += this.best_indent;\n      }\n    };\n    Emitter.prototype.expect_stream_start = function () {\n      if (this.event instanceof events.StreamStartEvent) {\n        if (this.event.encoding && !('encoding' in this.stream)) {\n          this.encoding = this.event.encoding;\n        }\n        this.write_stream_start();\n        return this.state = this.expect_first_document_start;\n      } else {\n        return this.error('expected StreamStartEvent, but got', this.event);\n      }\n    };\n    Emitter.prototype.expect_nothing = function () {\n      return this.error('expected nothing, but got', this.event);\n    };\n    Emitter.prototype.expect_first_document_start = function () {\n      return this.expect_document_start(true);\n    };\n    Emitter.prototype.expect_document_start = function (first) {\n      var explicit, handle, i, k, len, prefix, ref;\n      if (first == null) {\n        first = false;\n      }\n      if (this.event instanceof events.DocumentStartEvent) {\n        if ((this.event.version || this.event.tags) && this.open_ended) {\n          this.write_indicator('...', true);\n          this.write_indent();\n        }\n        if (this.event.version) {\n          this.write_version_directive(this.prepare_version(this.event.version));\n        }\n        this.tag_prefixes = util.clone(DEFAULT_TAG_PREFIXES);\n        if (this.event.tags) {\n          ref = function () {\n            var ref, results;\n            ref = this.event.tags;\n            results = [];\n            for (k in ref) {\n              if (!hasProp.call(ref, k)) continue;\n              results.push(k);\n            }\n            return results;\n          }.call(this).sort();\n          for (i = 0, len = ref.length; i < len; i++) {\n            handle = ref[i];\n            prefix = this.event.tags[handle];\n            this.tag_prefixes[prefix] = handle;\n            this.write_tag_directive(this.prepare_tag_handle(handle), this.prepare_tag_prefix(prefix));\n          }\n        }\n        explicit = !first || this.event.explicit || this.canonical || this.event.version || this.event.tags || this.check_empty_document();\n        if (explicit) {\n          this.write_indent();\n          this.write_indicator('---', true);\n          if (this.canonical) {\n            this.write_indent();\n          }\n        }\n        return this.state = this.expect_document_root;\n      } else if (this.event instanceof events.StreamEndEvent) {\n        if (this.open_ended) {\n          this.write_indicator('...', true);\n          this.write_indent();\n        }\n        this.write_stream_end();\n        return this.state = this.expect_nothing;\n      } else {\n        return this.error('expected DocumentStartEvent, but got', this.event);\n      }\n    };\n    Emitter.prototype.expect_document_end = function () {\n      if (this.event instanceof events.DocumentEndEvent) {\n        this.write_indent();\n        if (this.event.explicit) {\n          this.write_indicator('...', true);\n          this.write_indent();\n        }\n        this.flush_stream();\n        return this.state = this.expect_document_start;\n      } else {\n        return this.error('expected DocumentEndEvent, but got', this.event);\n      }\n    };\n    Emitter.prototype.expect_document_root = function () {\n      this.states.push(this.expect_document_end);\n      return this.expect_node({\n        root: true\n      });\n    };\n    Emitter.prototype.expect_node = function (expect) {\n      if (expect == null) {\n        expect = {};\n      }\n      this.root_context = !!expect.root;\n      this.sequence_context = !!expect.sequence;\n      this.mapping_context = !!expect.mapping;\n      this.simple_key_context = !!expect.simple_key;\n      if (this.event instanceof events.AliasEvent) {\n        return this.expect_alias();\n      } else if (this.event instanceof events.ScalarEvent || this.event instanceof events.CollectionStartEvent) {\n        this.process_anchor('&');\n        this.process_tag();\n        if (this.event instanceof events.ScalarEvent) {\n          return this.expect_scalar();\n        } else if (this.event instanceof events.SequenceStartEvent) {\n          if (this.flow_level || this.canonical || this.event.flow_style || this.check_empty_sequence()) {\n            return this.expect_flow_sequence();\n          } else {\n            return this.expect_block_sequence();\n          }\n        } else if (this.event instanceof events.MappingStartEvent) {\n          if (this.flow_level || this.canonical || this.event.flow_style || this.check_empty_mapping()) {\n            return this.expect_flow_mapping();\n          } else {\n            return this.expect_block_mapping();\n          }\n        }\n      } else {\n        return this.error('expected NodeEvent, but got', this.event);\n      }\n    };\n    Emitter.prototype.expect_alias = function () {\n      if (!this.event.anchor) {\n        this.error('anchor is not specified for alias');\n      }\n      this.process_anchor('*');\n      return this.state = this.states.pop();\n    };\n    Emitter.prototype.expect_scalar = function () {\n      this.increase_indent({\n        flow: true\n      });\n      this.process_scalar();\n      this.indent = this.indents.pop();\n      return this.state = this.states.pop();\n    };\n    Emitter.prototype.expect_flow_sequence = function () {\n      this.write_indicator('[', true, {\n        whitespace: true\n      });\n      this.flow_level++;\n      this.increase_indent({\n        flow: true\n      });\n      return this.state = this.expect_first_flow_sequence_item;\n    };\n    Emitter.prototype.expect_first_flow_sequence_item = function () {\n      if (this.event instanceof events.SequenceEndEvent) {\n        this.indent = this.indents.pop();\n        this.flow_level--;\n        this.write_indicator(']', false);\n        return this.state = this.states.pop();\n      } else {\n        if (this.canonical || this.column > this.best_width) {\n          this.write_indent();\n        }\n        this.states.push(this.expect_flow_sequence_item);\n        return this.expect_node({\n          sequence: true\n        });\n      }\n    };\n    Emitter.prototype.expect_flow_sequence_item = function () {\n      if (this.event instanceof events.SequenceEndEvent) {\n        this.indent = this.indents.pop();\n        this.flow_level--;\n        if (this.canonical) {\n          this.write_indicator(',', false);\n          this.write_indent();\n        }\n        this.write_indicator(']', false);\n        return this.state = this.states.pop();\n      } else {\n        this.write_indicator(',', false);\n        if (this.canonical || this.column > this.best_width) {\n          this.write_indent();\n        }\n        this.states.push(this.expect_flow_sequence_item);\n        return this.expect_node({\n          sequence: true\n        });\n      }\n    };\n    Emitter.prototype.expect_flow_mapping = function () {\n      this.write_indicator('{', true, {\n        whitespace: true\n      });\n      this.flow_level++;\n      this.increase_indent({\n        flow: true\n      });\n      return this.state = this.expect_first_flow_mapping_key;\n    };\n    Emitter.prototype.expect_first_flow_mapping_key = function () {\n      if (this.event instanceof events.MappingEndEvent) {\n        this.indent = this.indents.pop();\n        this.flow_level--;\n        this.write_indicator('}', false);\n        return this.state = this.states.pop();\n      } else {\n        if (this.canonical || this.column > this.best_width) {\n          this.write_indent();\n        }\n        if (!this.canonical && this.check_simple_key()) {\n          this.states.push(this.expect_flow_mapping_simple_value);\n          return this.expect_node({\n            mapping: true,\n            simple_key: true\n          });\n        } else {\n          this.write_indicator('?', true);\n          this.states.push(this.expect_flow_mapping_value);\n          return this.expect_node({\n            mapping: true\n          });\n        }\n      }\n    };\n    Emitter.prototype.expect_flow_mapping_key = function () {\n      if (this.event instanceof events.MappingEndEvent) {\n        this.indent = this.indents.pop();\n        this.flow_level--;\n        if (this.canonical) {\n          this.write_indicator(',', false);\n          this.write_indent();\n        }\n        this.write_indicator('}', false);\n        return this.state = this.states.pop();\n      } else {\n        this.write_indicator(',', false);\n        if (this.canonical || this.column > this.best_width) {\n          this.write_indent();\n        }\n        if (!this.canonical && this.check_simple_key()) {\n          this.states.push(this.expect_flow_mapping_simple_value);\n          return this.expect_node({\n            mapping: true,\n            simple_key: true\n          });\n        } else {\n          this.write_indicator('?', true);\n          this.states.push(this.expect_flow_mapping_value);\n          return this.expect_node({\n            mapping: true\n          });\n        }\n      }\n    };\n    Emitter.prototype.expect_flow_mapping_simple_value = function () {\n      this.write_indicator(':', false);\n      this.states.push(this.expect_flow_mapping_key);\n      return this.expect_node({\n        mapping: true\n      });\n    };\n    Emitter.prototype.expect_flow_mapping_value = function () {\n      if (this.canonical || this.column > this.best_width) {\n        this.write_indent();\n      }\n      this.write_indicator(':', true);\n      this.states.push(this.expect_flow_mapping_key);\n      return this.expect_node({\n        mapping: true\n      });\n    };\n    Emitter.prototype.expect_block_sequence = function () {\n      var indentless;\n      indentless = this.mapping_context && !this.indentation;\n      this.increase_indent({\n        indentless: indentless\n      });\n      return this.state = this.expect_first_block_sequence_item;\n    };\n    Emitter.prototype.expect_first_block_sequence_item = function () {\n      return this.expect_block_sequence_item(true);\n    };\n    Emitter.prototype.expect_block_sequence_item = function (first) {\n      if (first == null) {\n        first = false;\n      }\n      if (!first && this.event instanceof events.SequenceEndEvent) {\n        this.indent = this.indents.pop();\n        return this.state = this.states.pop();\n      } else {\n        this.write_indent();\n        this.write_indicator('-', true, {\n          indentation: true\n        });\n        this.states.push(this.expect_block_sequence_item);\n        return this.expect_node({\n          sequence: true\n        });\n      }\n    };\n    Emitter.prototype.expect_block_mapping = function () {\n      this.increase_indent();\n      return this.state = this.expect_first_block_mapping_key;\n    };\n    Emitter.prototype.expect_first_block_mapping_key = function () {\n      return this.expect_block_mapping_key(true);\n    };\n    Emitter.prototype.expect_block_mapping_key = function (first) {\n      if (first == null) {\n        first = false;\n      }\n      if (!first && this.event instanceof events.MappingEndEvent) {\n        this.indent = this.indents.pop();\n        return this.state = this.states.pop();\n      } else {\n        this.write_indent();\n        if (this.check_simple_key()) {\n          this.states.push(this.expect_block_mapping_simple_value);\n          return this.expect_node({\n            mapping: true,\n            simple_key: true\n          });\n        } else {\n          this.write_indicator('?', true, {\n            indentation: true\n          });\n          this.states.push(this.expect_block_mapping_value);\n          return this.expect_node({\n            mapping: true\n          });\n        }\n      }\n    };\n    Emitter.prototype.expect_block_mapping_simple_value = function () {\n      this.write_indicator(':', false);\n      this.states.push(this.expect_block_mapping_key);\n      return this.expect_node({\n        mapping: true\n      });\n    };\n    Emitter.prototype.expect_block_mapping_value = function () {\n      this.write_indent();\n      this.write_indicator(':', true, {\n        indentation: true\n      });\n      this.states.push(this.expect_block_mapping_key);\n      return this.expect_node({\n        mapping: true\n      });\n    };\n    Emitter.prototype.check_empty_document = function () {\n      var event;\n      if (!(this.event instanceof events.DocumentStartEvent) || this.events.length === 0) {\n        return false;\n      }\n      event = this.events[0];\n      return event instanceof events.ScalarEvent && event.anchor == null && event.tag == null && event.implicit && event.value === '';\n    };\n    Emitter.prototype.check_empty_sequence = function () {\n      return this.event instanceof events.SequenceStartEvent && this.events[0] instanceof events.SequenceEndEvent;\n    };\n    Emitter.prototype.check_empty_mapping = function () {\n      return this.event instanceof events.MappingStartEvent && this.events[0] instanceof events.MappingEndEvent;\n    };\n    Emitter.prototype.check_simple_key = function () {\n      var length;\n      length = 0;\n      if (this.event instanceof events.NodeEvent && this.event.anchor != null) {\n        if (this.prepared_anchor == null) {\n          this.prepared_anchor = this.prepare_anchor(this.event.anchor);\n        }\n        length += this.prepared_anchor.length;\n      }\n      if (this.event.tag != null && (this.event instanceof events.ScalarEvent || this.event instanceof events.CollectionStartEvent)) {\n        if (this.prepared_tag == null) {\n          this.prepared_tag = this.prepare_tag(this.event.tag);\n        }\n        length += this.prepared_tag.length;\n      }\n      if (this.event instanceof events.ScalarEvent) {\n        if (this.analysis == null) {\n          this.analysis = this.analyze_scalar(this.event.value);\n        }\n        length += this.analysis.scalar.length;\n      }\n      return length < 128 && (this.event instanceof events.AliasEvent || this.event instanceof events.ScalarEvent && !this.analysis.empty && !this.analysis.multiline || this.check_empty_sequence() || this.check_empty_mapping());\n    };\n    Emitter.prototype.process_anchor = function (indicator) {\n      if (this.event.anchor == null) {\n        this.prepared_anchor = null;\n        return;\n      }\n      if (this.prepared_anchor == null) {\n        this.prepared_anchor = this.prepare_anchor(this.event.anchor);\n      }\n      if (this.prepared_anchor) {\n        this.write_indicator(\"\" + indicator + this.prepared_anchor, true);\n      }\n      return this.prepared_anchor = null;\n    };\n    Emitter.prototype.process_tag = function () {\n      var tag;\n      tag = this.event.tag;\n      if (this.event instanceof events.ScalarEvent) {\n        if (this.style == null) {\n          this.style = this.choose_scalar_style();\n        }\n        if ((!this.canonical || tag == null) && (this.style === '' && this.event.implicit[0] || this.style !== '' && this.event.implicit[1])) {\n          this.prepared_tag = null;\n          return;\n        }\n        if (this.event.implicit[0] && tag == null) {\n          tag = '!';\n          this.prepared_tag = null;\n        }\n      } else if ((!this.canonical || tag == null) && this.event.implicit) {\n        this.prepared_tag = null;\n        return;\n      }\n      if (tag == null) {\n        this.error('tag is not specified');\n      }\n      if (this.prepared_tag == null) {\n        this.prepared_tag = this.prepare_tag(tag);\n      }\n      this.write_indicator(this.prepared_tag, true);\n      return this.prepared_tag = null;\n    };\n    Emitter.prototype.process_scalar = function () {\n      var split;\n      if (this.analysis == null) {\n        this.analysis = this.analyze_scalar(this.event.value);\n      }\n      if (this.style == null) {\n        this.style = this.choose_scalar_style();\n      }\n      split = !this.simple_key_context;\n      switch (this.style) {\n        case '\"':\n          this.write_double_quoted(this.analysis.scalar, split);\n          break;\n        case \"'\":\n          this.write_single_quoted(this.analysis.scalar, split);\n          break;\n        case '>':\n          this.write_folded(this.analysis.scalar);\n          break;\n        case '|':\n          this.write_literal(this.analysis.scalar);\n          break;\n        default:\n          this.write_plain(this.analysis.scalar, split);\n      }\n      this.analysis = null;\n      return this.style = null;\n    };\n    Emitter.prototype.choose_scalar_style = function () {\n      var ref;\n      if (this.analysis == null) {\n        this.analysis = this.analyze_scalar(this.event.value);\n      }\n      if (this.event.style === '\"' || this.canonical) {\n        return '\"';\n      }\n      if (!this.event.style && this.event.implicit[0] && !(this.simple_key_context && (this.analysis.empty || this.analysis.multiline)) && (this.flow_level && this.analysis.allow_flow_plain || !this.flow_level && this.analysis.allow_block_plain)) {\n        return '';\n      }\n      if (this.event.style && (ref = this.event.style, indexOf.call('|>', ref) >= 0) && !this.flow_level && !this.simple_key_context && this.analysis.allow_block) {\n        return this.event.style;\n      }\n      if ((!this.event.style || this.event.style === \"'\") && this.analysis.allow_single_quoted && !(this.simple_key_context && this.analysis.multiline)) {\n        return \"'\";\n      }\n      return '\"';\n    };\n    Emitter.prototype.prepare_version = function (arg) {\n      var major, minor, version;\n      major = arg[0], minor = arg[1];\n      version = major + \".\" + minor;\n      if (major === 1) {\n        return version;\n      } else {\n        return this.error('unsupported YAML version', version);\n      }\n    };\n    Emitter.prototype.prepare_tag_handle = function (handle) {\n      var char, i, len, ref;\n      if (!handle) {\n        this.error('tag handle must not be empty');\n      }\n      if (handle[0] !== '!' || handle.slice(-1) !== '!') {\n        this.error(\"tag handle must start and end with '!':\", handle);\n      }\n      ref = handle.slice(1, -1);\n      for (i = 0, len = ref.length; i < len; i++) {\n        char = ref[i];\n        if (!('0' <= char && char <= '9' || 'A' <= char && char <= 'Z' || 'a' <= char && char <= 'z' || indexOf.call('-_', char) >= 0)) {\n          this.error(\"invalid character '\" + char + \"' in the tag handle:\", handle);\n        }\n      }\n      return handle;\n    };\n    Emitter.prototype.prepare_tag_prefix = function (prefix) {\n      var char, chunks, end, start;\n      if (!prefix) {\n        this.error('tag prefix must not be empty');\n      }\n      chunks = [];\n      start = 0;\n      end = +(prefix[0] === '!');\n      while (end < prefix.length) {\n        char = prefix[end];\n        if ('0' <= char && char <= '9' || 'A' <= char && char <= 'Z' || 'a' <= char && char <= 'z' || indexOf.call('-;/?!:@&=+$,_.~*\\'()[]', char) >= 0) {\n          end++;\n        } else {\n          if (start < end) {\n            chunks.push(prefix.slice(start, end));\n          }\n          start = end = end + 1;\n          chunks.push(char);\n        }\n      }\n      if (start < end) {\n        chunks.push(prefix.slice(start, end));\n      }\n      return chunks.join('');\n    };\n    Emitter.prototype.prepare_tag = function (tag) {\n      var char, chunks, end, handle, i, k, len, prefix, ref, start, suffix, suffix_text;\n      if (!tag) {\n        this.error('tag must not be empty');\n      }\n      if (tag === '!') {\n        return tag;\n      }\n      handle = null;\n      suffix = tag;\n      ref = function () {\n        var ref, results;\n        ref = this.tag_prefixes;\n        results = [];\n        for (k in ref) {\n          if (!hasProp.call(ref, k)) continue;\n          results.push(k);\n        }\n        return results;\n      }.call(this).sort();\n      for (i = 0, len = ref.length; i < len; i++) {\n        prefix = ref[i];\n        if (tag.indexOf(prefix) === 0 && (prefix === '!' || prefix.length < tag.length)) {\n          handle = this.tag_prefixes[prefix];\n          suffix = tag.slice(prefix.length);\n        }\n      }\n      chunks = [];\n      start = end = 0;\n      while (end < suffix.length) {\n        char = suffix[end];\n        if ('0' <= char && char <= '9' || 'A' <= char && char <= 'Z' || 'a' <= char && char <= 'z' || indexOf.call('-;/?!:@&=+$,_.~*\\'()[]', char) >= 0 || char === '!' && handle !== '!') {\n          end++;\n        } else {\n          if (start < end) {\n            chunks.push(suffix.slice(start, end));\n          }\n          start = end = end + 1;\n          chunks.push(char);\n        }\n      }\n      if (start < end) {\n        chunks.push(suffix.slice(start, end));\n      }\n      suffix_text = chunks.join('');\n      if (handle) {\n        return \"\" + handle + suffix_text;\n      } else {\n        return \"!<\" + suffix_text + \">\";\n      }\n    };\n    Emitter.prototype.prepare_anchor = function (anchor) {\n      var char, i, len;\n      if (!anchor) {\n        this.error('anchor must not be empty');\n      }\n      for (i = 0, len = anchor.length; i < len; i++) {\n        char = anchor[i];\n        if (!('0' <= char && char <= '9' || 'A' <= char && char <= 'Z' || 'a' <= char && char <= 'z' || indexOf.call('-_', char) >= 0)) {\n          this.error(\"invalid character '\" + char + \"' in the anchor:\", anchor);\n        }\n      }\n      return anchor;\n    };\n    Emitter.prototype.analyze_scalar = function (scalar) {\n      var allow_block, allow_block_plain, allow_double_quoted, allow_flow_plain, allow_single_quoted, block_indicators, break_space, char, flow_indicators, followed_by_whitespace, i, index, leading_break, leading_space, len, line_breaks, preceded_by_whitespace, previous_break, previous_space, ref, ref1, space_break, special_characters, trailing_break, trailing_space, unicode_characters;\n      if (!scalar) {\n        new ScalarAnalysis(scalar, true, false, false, true, true, true, false);\n      }\n      block_indicators = false;\n      flow_indicators = false;\n      line_breaks = false;\n      special_characters = false;\n      unicode_characters = false;\n      leading_space = false;\n      leading_break = false;\n      trailing_space = false;\n      trailing_break = false;\n      break_space = false;\n      space_break = false;\n      if (scalar.indexOf('---') === 0 || scalar.indexOf('...') === 0) {\n        block_indicators = true;\n        flow_indicators = true;\n      }\n      preceded_by_whitespace = true;\n      followed_by_whitespace = scalar.length === 1 || (ref = scalar[1], indexOf.call('\\0 \\t\\r\\n\\x85\\u2028\\u2029', ref) >= 0);\n      previous_space = false;\n      previous_break = false;\n      index = 0;\n      for (index = i = 0, len = scalar.length; i < len; index = ++i) {\n        char = scalar[index];\n        if (index === 0) {\n          if (indexOf.call('#,[]{}&*!|>\\'\"%@`', char) >= 0 || char === '-' && followed_by_whitespace) {\n            flow_indicators = true;\n            block_indicators = true;\n          } else if (indexOf.call('?:', char) >= 0) {\n            flow_indicators = true;\n            if (followed_by_whitespace) {\n              block_indicators = true;\n            }\n          }\n        } else {\n          if (indexOf.call(',?[]{}', char) >= 0) {\n            flow_indicators = true;\n          } else if (char === ':') {\n            flow_indicators = true;\n            if (followed_by_whitespace) {\n              block_indicators = true;\n            }\n          } else if (char === '#' && preceded_by_whitespace) {\n            flow_indicators = true;\n            block_indicators = true;\n          }\n        }\n        if (indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n          line_breaks = true;\n        }\n        if (!(char === '\\n' || '\\x20' <= char && char <= '\\x7e')) {\n          if (char !== '\\uFEFF' && (char === '\\x85' || '\\xA0' <= char && char <= '\\uD7FF' || '\\uE000' <= char && char <= '\\uFFFD')) {\n            unicode_characters = true;\n            if (!this.allow_unicode) {\n              special_characters = true;\n            }\n          } else {\n            special_characters = true;\n          }\n        }\n        if (char === ' ') {\n          if (index === 0) {\n            leading_space = true;\n          }\n          if (index === scalar.length - 1) {\n            trailing_space = true;\n          }\n          if (previous_break) {\n            break_space = true;\n          }\n          previous_break = false;\n          previous_space = true;\n        } else if (indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n          if (index === 0) {\n            leading_break = true;\n          }\n          if (index === scalar.length - 1) {\n            trailing_break = true;\n          }\n          if (previous_space) {\n            space_break = true;\n          }\n          previous_break = true;\n          previous_space = false;\n        } else {\n          previous_break = false;\n          previous_space = false;\n        }\n        preceded_by_whitespace = indexOf.call(C_WHITESPACE, char) >= 0;\n        followed_by_whitespace = index + 2 >= scalar.length || (ref1 = scalar[index + 2], indexOf.call(C_WHITESPACE, ref1) >= 0);\n      }\n      allow_flow_plain = true;\n      allow_block_plain = true;\n      allow_single_quoted = true;\n      allow_double_quoted = true;\n      allow_block = true;\n      if (leading_space || leading_break || trailing_space || trailing_break) {\n        allow_flow_plain = allow_block_plain = false;\n      }\n      if (trailing_space) {\n        allow_block = false;\n      }\n      if (break_space) {\n        allow_flow_plain = allow_block_plain = allow_single_quoted = false;\n      }\n      if (space_break || special_characters) {\n        allow_flow_plain = allow_block_plain = allow_single_quoted = allow_block = false;\n      }\n      if (line_breaks) {\n        allow_flow_plain = allow_block_plain = false;\n      }\n      if (flow_indicators) {\n        allow_flow_plain = false;\n      }\n      if (block_indicators) {\n        allow_block_plain = false;\n      }\n      return new ScalarAnalysis(scalar, false, line_breaks, allow_flow_plain, allow_block_plain, allow_single_quoted, allow_double_quoted, allow_block);\n    };\n\n    /*\n    Write BOM if needed.\n     */\n\n    Emitter.prototype.write_stream_start = function () {\n      if (this.encoding && this.encoding.indexOf('utf-16') === 0) {\n        return this.stream.write('\\uFEFF', this.encoding);\n      }\n    };\n    Emitter.prototype.write_stream_end = function () {\n      return this.flush_stream();\n    };\n    Emitter.prototype.write_indicator = function (indicator, need_whitespace, options) {\n      var data;\n      if (options == null) {\n        options = {};\n      }\n      data = this.whitespace || !need_whitespace ? indicator : ' ' + indicator;\n      this.whitespace = !!options.whitespace;\n      this.indentation && (this.indentation = !!options.indentation);\n      this.column += data.length;\n      this.open_ended = false;\n      return this.stream.write(data, this.encoding);\n    };\n    Emitter.prototype.write_indent = function () {\n      var data, indent, ref;\n      indent = (ref = this.indent) != null ? ref : 0;\n      if (!this.indentation || this.column > indent || this.column === indent && !this.whitespace) {\n        this.write_line_break();\n      }\n      if (this.column < indent) {\n        this.whitespace = true;\n        data = new Array(indent - this.column + 1).join(' ');\n        this.column = indent;\n        return this.stream.write(data, this.encoding);\n      }\n    };\n    Emitter.prototype.write_line_break = function (data) {\n      this.whitespace = true;\n      this.indentation = true;\n      this.line += 1;\n      this.column = 0;\n      return this.stream.write(data != null ? data : this.best_line_break, this.encoding);\n    };\n    Emitter.prototype.write_version_directive = function (version_text) {\n      this.stream.write(\"%YAML \" + version_text, this.encoding);\n      return this.write_line_break();\n    };\n    Emitter.prototype.write_tag_directive = function (handle_text, prefix_text) {\n      this.stream.write(\"%TAG \" + handle_text + \" \" + prefix_text, this.encoding);\n      return this.write_line_break();\n    };\n    Emitter.prototype.write_single_quoted = function (text, split) {\n      var br, breaks, char, data, end, i, len, ref, spaces, start;\n      if (split == null) {\n        split = true;\n      }\n      this.write_indicator(\"'\", true);\n      spaces = false;\n      breaks = false;\n      start = end = 0;\n      while (end <= text.length) {\n        char = text[end];\n        if (spaces) {\n          if (char == null || char !== ' ') {\n            if (start + 1 === end && this.column > this.best_width && split && start !== 0 && end !== text.length) {\n              this.write_indent();\n            } else {\n              data = text.slice(start, end);\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n            }\n            start = end;\n          }\n        } else if (breaks) {\n          if (char == null || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n            if (text[start] === '\\n') {\n              this.write_line_break();\n            }\n            ref = text.slice(start, end);\n            for (i = 0, len = ref.length; i < len; i++) {\n              br = ref[i];\n              if (br === '\\n') {\n                this.write_line_break();\n              } else {\n                this.write_line_break(br);\n              }\n            }\n            this.write_indent();\n            start = end;\n          }\n        } else if ((char == null || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0 || char === \"'\") && start < end) {\n          data = text.slice(start, end);\n          this.column += data.length;\n          this.stream.write(data, this.encoding);\n          start = end;\n        }\n        if (char === \"'\") {\n          this.column += 2;\n          this.stream.write(\"''\", this.encoding);\n          start = end + 1;\n        }\n        if (char != null) {\n          spaces = char === ' ';\n          breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n        }\n        end++;\n      }\n      return this.write_indicator(\"'\", false);\n    };\n    Emitter.prototype.write_double_quoted = function (text, split) {\n      var char, data, end, start;\n      if (split == null) {\n        split = true;\n      }\n      this.write_indicator('\"', true);\n      start = end = 0;\n      while (end <= text.length) {\n        char = text[end];\n        if (char == null || indexOf.call('\"\\\\\\x85\\u2028\\u2029\\uFEFF', char) >= 0 || !('\\x20' <= char && char <= '\\x7E' || this.allow_unicode && ('\\xA0' <= char && char <= '\\uD7FF' || '\\uE000' <= char && char <= '\\uFFFD'))) {\n          if (start < end) {\n            data = text.slice(start, end);\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            start = end;\n          }\n          if (char != null) {\n            data = char in ESCAPE_REPLACEMENTS ? '\\\\' + ESCAPE_REPLACEMENTS[char] : char <= '\\xFF' ? \"\\\\x\" + util.pad_left(util.to_hex(char), '0', 2) : char <= '\\uFFFF' ? \"\\\\u\" + util.pad_left(util.to_hex(char), '0', 4) : \"\\\\U\" + util.pad_left(util.to_hex(char), '0', 16);\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            start = end + 1;\n          }\n        }\n        if (split && 0 < end && end < text.length - 1 && (char === ' ' || start >= end) && this.column + (end - start) > this.best_width) {\n          data = text.slice(start, end) + \"\\\\\";\n          if (start < end) {\n            start = end;\n          }\n          this.column += data.length;\n          this.stream.write(data, this.encoding);\n          this.write_indent();\n          this.whitespace = false;\n          this.indentation = false;\n          if (text[start] === ' ') {\n            data = '\\\\';\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n          }\n        }\n        end++;\n      }\n      return this.write_indicator('\"', false);\n    };\n    Emitter.prototype.write_folded = function (text) {\n      var br, breaks, char, data, end, hints, i, leading_space, len, ref, results, spaces, start;\n      hints = this.determine_block_hints(text);\n      this.write_indicator(\">\" + hints, true);\n      if (hints.slice(-1) === '+') {\n        this.open_ended = true;\n      }\n      this.write_line_break();\n      leading_space = true;\n      breaks = true;\n      spaces = false;\n      start = end = 0;\n      results = [];\n      while (end <= text.length) {\n        char = text[end];\n        if (breaks) {\n          if (char == null || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n            if (!leading_space && char != null && char !== ' ' && text[start] === '\\n') {\n              this.write_line_break();\n            }\n            leading_space = char === ' ';\n            ref = text.slice(start, end);\n            for (i = 0, len = ref.length; i < len; i++) {\n              br = ref[i];\n              if (br === '\\n') {\n                this.write_line_break();\n              } else {\n                this.write_line_break(br);\n              }\n            }\n            if (char != null) {\n              this.write_indent();\n            }\n            start = end;\n          }\n        } else if (spaces) {\n          if (char !== ' ') {\n            if (start + 1 === end && this.column > this.best_width) {\n              this.write_indent();\n            } else {\n              data = text.slice(start, end);\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n            }\n            start = end;\n          }\n        } else if (char == null || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0) {\n          data = text.slice(start, end);\n          this.column += data.length;\n          this.stream.write(data, this.encoding);\n          if (char == null) {\n            this.write_line_break();\n          }\n          start = end;\n        }\n        if (char != null) {\n          breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n          spaces = char === ' ';\n        }\n        results.push(end++);\n      }\n      return results;\n    };\n    Emitter.prototype.write_literal = function (text) {\n      var br, breaks, char, data, end, hints, i, len, ref, results, start;\n      hints = this.determine_block_hints(text);\n      this.write_indicator(\"|\" + hints, true);\n      if (hints.slice(-1) === '+') {\n        this.open_ended = true;\n      }\n      this.write_line_break();\n      breaks = true;\n      start = end = 0;\n      results = [];\n      while (end <= text.length) {\n        char = text[end];\n        if (breaks) {\n          if (char == null || indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n            ref = text.slice(start, end);\n            for (i = 0, len = ref.length; i < len; i++) {\n              br = ref[i];\n              if (br === '\\n') {\n                this.write_line_break();\n              } else {\n                this.write_line_break(br);\n              }\n            }\n            if (char != null) {\n              this.write_indent();\n            }\n            start = end;\n          }\n        } else {\n          if (char == null || indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0) {\n            data = text.slice(start, end);\n            this.stream.write(data, this.encoding);\n            if (char == null) {\n              this.write_line_break();\n            }\n            start = end;\n          }\n        }\n        if (char != null) {\n          breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n        }\n        results.push(end++);\n      }\n      return results;\n    };\n    Emitter.prototype.write_plain = function (text, split) {\n      var br, breaks, char, data, end, i, len, ref, results, spaces, start;\n      if (split == null) {\n        split = true;\n      }\n      if (!text) {\n        return;\n      }\n      if (this.root_context) {\n        this.open_ended = true;\n      }\n      if (!this.whitespace) {\n        data = ' ';\n        this.column += data.length;\n        this.stream.write(data, this.encoding);\n      }\n      this.whitespace = false;\n      this.indentation = false;\n      spaces = false;\n      breaks = false;\n      start = end = 0;\n      results = [];\n      while (end <= text.length) {\n        char = text[end];\n        if (spaces) {\n          if (char !== ' ') {\n            if (start + 1 === end && this.column > this.best_width && split) {\n              this.write_indent();\n              this.whitespace = false;\n              this.indentation = false;\n            } else {\n              data = text.slice(start, end);\n              this.column += data.length;\n              this.stream.write(data, this.encoding);\n            }\n            start = end;\n          }\n        } else if (breaks) {\n          if (indexOf.call('\\n\\x85\\u2028\\u2029', char) < 0) {\n            if (text[start] === '\\n') {\n              this.write_line_break();\n            }\n            ref = text.slice(start, end);\n            for (i = 0, len = ref.length; i < len; i++) {\n              br = ref[i];\n              if (br === '\\n') {\n                this.write_line_break();\n              } else {\n                this.write_line_break(br);\n              }\n            }\n            this.write_indent();\n            this.whitespace = false;\n            this.indentation = false;\n            start = end;\n          }\n        } else {\n          if (char == null || indexOf.call(' \\n\\x85\\u2028\\u2029', char) >= 0) {\n            data = text.slice(start, end);\n            this.column += data.length;\n            this.stream.write(data, this.encoding);\n            start = end;\n          }\n        }\n        if (char != null) {\n          spaces = char === ' ';\n          breaks = indexOf.call('\\n\\x85\\u2028\\u2029', char) >= 0;\n        }\n        results.push(end++);\n      }\n      return results;\n    };\n    Emitter.prototype.determine_block_hints = function (text) {\n      var first, hints, i, last, penultimate;\n      hints = '';\n      first = text[0], i = text.length - 2, penultimate = text[i++], last = text[i++];\n      if (indexOf.call(' \\n\\x85\\u2028\\u2029', first) >= 0) {\n        hints += this.best_indent;\n      }\n      if (indexOf.call('\\n\\x85\\u2028\\u2029', last) < 0) {\n        hints += '-';\n      } else if (text.length === 1 || indexOf.call('\\n\\x85\\u2028\\u2029', penultimate) >= 0) {\n        hints += '+';\n      }\n      return hints;\n    };\n    Emitter.prototype.flush_stream = function () {\n      var base;\n      return typeof (base = this.stream).flush === \"function\" ? base.flush() : void 0;\n    };\n\n    /*\n    Helper for common error pattern.\n     */\n\n    Emitter.prototype.error = function (message, context) {\n      var ref, ref1;\n      if (context) {\n        context = (ref = context != null ? (ref1 = context.constructor) != null ? ref1.name : void 0 : void 0) != null ? ref : util.inspect(context);\n      }\n      throw new exports.EmitterError(\"\" + message + (context ? \" \" + context : ''));\n    };\n    return Emitter;\n  }();\n  ScalarAnalysis = function () {\n    function ScalarAnalysis(scalar1, empty, multiline, allow_flow_plain1, allow_block_plain1, allow_single_quoted1, allow_double_quoted1, allow_block1) {\n      this.scalar = scalar1;\n      this.empty = empty;\n      this.multiline = multiline;\n      this.allow_flow_plain = allow_flow_plain1;\n      this.allow_block_plain = allow_block_plain1;\n      this.allow_single_quoted = allow_single_quoted1;\n      this.allow_double_quoted = allow_double_quoted1;\n      this.allow_block = allow_block1;\n    }\n    return ScalarAnalysis;\n  }();\n}).call(this);","map":null,"metadata":{},"sourceType":"script"}