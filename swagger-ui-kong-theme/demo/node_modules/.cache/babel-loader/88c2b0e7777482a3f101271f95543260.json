{"ast":null,"code":"\"use strict\";\n\nrequire(\"./Polyfills\");\nvar get = require(\"lodash.get\");\nvar Report = require(\"./Report\");\nvar FormatValidators = require(\"./FormatValidators\");\nvar JsonValidation = require(\"./JsonValidation\");\nvar SchemaCache = require(\"./SchemaCache\");\nvar SchemaCompilation = require(\"./SchemaCompilation\");\nvar SchemaValidation = require(\"./SchemaValidation\");\nvar Utils = require(\"./Utils\");\nvar Draft4Schema = require(\"./schemas/schema.json\");\nvar Draft4HyperSchema = require(\"./schemas/hyper-schema.json\");\n\n/**\n * default options\n */\nvar defaultOptions = {\n  // default timeout for all async tasks\n  asyncTimeout: 2000,\n  // force additionalProperties and additionalItems to be defined on \"object\" and \"array\" types\n  forceAdditional: false,\n  // assume additionalProperties and additionalItems are defined as \"false\" where appropriate\n  assumeAdditional: false,\n  // do case insensitive comparison for enums\n  enumCaseInsensitiveComparison: false,\n  // force items to be defined on \"array\" types\n  forceItems: false,\n  // force minItems to be defined on \"array\" types\n  forceMinItems: false,\n  // force maxItems to be defined on \"array\" types\n  forceMaxItems: false,\n  // force minLength to be defined on \"string\" types\n  forceMinLength: false,\n  // force maxLength to be defined on \"string\" types\n  forceMaxLength: false,\n  // force properties or patternProperties to be defined on \"object\" types\n  forceProperties: false,\n  // ignore references that cannot be resolved (remote schemas) // TODO: make sure this is only for remote schemas, not local ones\n  ignoreUnresolvableReferences: false,\n  // disallow usage of keywords that this validator can't handle\n  noExtraKeywords: false,\n  // disallow usage of schema's without \"type\" defined\n  noTypeless: false,\n  // disallow zero length strings in validated objects\n  noEmptyStrings: false,\n  // disallow zero length arrays in validated objects\n  noEmptyArrays: false,\n  // forces \"uri\" format to be in fully rfc3986 compliant\n  strictUris: false,\n  // turn on some of the above\n  strictMode: false,\n  // report error paths as an array of path segments to get to the offending node\n  reportPathAsArray: false,\n  // stops validation as soon as an error is found, true by default but can be turned off\n  breakOnFirstError: true,\n  // check if schema follows best practices and common sense\n  pedanticCheck: false,\n  // ignore unknown formats (do not report them as an error)\n  ignoreUnknownFormats: false,\n  // function to be called on every schema\n  customValidator: null\n};\nfunction normalizeOptions(options) {\n  var normalized;\n\n  // options\n  if (typeof options === \"object\") {\n    var keys = Object.keys(options),\n      idx = keys.length,\n      key;\n\n    // check that the options are correctly configured\n    while (idx--) {\n      key = keys[idx];\n      if (defaultOptions[key] === undefined) {\n        throw new Error(\"Unexpected option passed to constructor: \" + key);\n      }\n    }\n\n    // copy the default options into passed options\n    keys = Object.keys(defaultOptions);\n    idx = keys.length;\n    while (idx--) {\n      key = keys[idx];\n      if (options[key] === undefined) {\n        options[key] = Utils.clone(defaultOptions[key]);\n      }\n    }\n    normalized = options;\n  } else {\n    normalized = Utils.clone(defaultOptions);\n  }\n  if (normalized.strictMode === true) {\n    normalized.forceAdditional = true;\n    normalized.forceItems = true;\n    normalized.forceMaxLength = true;\n    normalized.forceProperties = true;\n    normalized.noExtraKeywords = true;\n    normalized.noTypeless = true;\n    normalized.noEmptyStrings = true;\n    normalized.noEmptyArrays = true;\n  }\n  return normalized;\n}\n\n/**\n * @class\n *\n * @param {*} [options]\n */\nfunction ZSchema(options) {\n  this.cache = {};\n  this.referenceCache = [];\n  this.validateOptions = {};\n  this.options = normalizeOptions(options);\n\n  // Disable strict validation for the built-in schemas\n  var metaschemaOptions = normalizeOptions({});\n  this.setRemoteReference(\"http://json-schema.org/draft-04/schema\", Draft4Schema, metaschemaOptions);\n  this.setRemoteReference(\"http://json-schema.org/draft-04/hyper-schema\", Draft4HyperSchema, metaschemaOptions);\n}\n\n/**\n * instance methods\n *\n * @param {*} schema\n *\n * @returns {boolean}\n */\nZSchema.prototype.compileSchema = function (schema) {\n  var report = new Report(this.options);\n  schema = SchemaCache.getSchema.call(this, report, schema);\n  SchemaCompilation.compileSchema.call(this, report, schema);\n  this.lastReport = report;\n  return report.isValid();\n};\n\n/**\n *\n * @param {*} schema\n *\n * @returns {boolean}\n */\nZSchema.prototype.validateSchema = function (schema) {\n  if (Array.isArray(schema) && schema.length === 0) {\n    throw new Error(\".validateSchema was called with an empty array\");\n  }\n  var report = new Report(this.options);\n  schema = SchemaCache.getSchema.call(this, report, schema);\n  var compiled = SchemaCompilation.compileSchema.call(this, report, schema);\n  if (compiled) {\n    SchemaValidation.validateSchema.call(this, report, schema);\n  }\n  this.lastReport = report;\n  return report.isValid();\n};\n\n/**\n *\n * @param {*} json\n * @param {*} schema\n * @param {*} [options]\n * @param {function(*, *)} [callback]\n *\n * @returns {boolean}\n */\nZSchema.prototype.validate = function (json, schema, options, callback) {\n  if (Utils.whatIs(options) === \"function\") {\n    callback = options;\n    options = {};\n  }\n  if (!options) {\n    options = {};\n  }\n  this.validateOptions = options;\n  var whatIs = Utils.whatIs(schema);\n  if (whatIs !== \"string\" && whatIs !== \"object\") {\n    var e = new Error(\"Invalid .validate call - schema must be an string or object but \" + whatIs + \" was passed!\");\n    if (callback) {\n      process.nextTick(function () {\n        callback(e, false);\n      });\n      return;\n    }\n    throw e;\n  }\n  var foundError = false;\n  var report = new Report(this.options);\n  report.json = json;\n  if (typeof schema === \"string\") {\n    var schemaName = schema;\n    schema = SchemaCache.getSchema.call(this, report, schemaName);\n    if (!schema) {\n      throw new Error(\"Schema with id '\" + schemaName + \"' wasn't found in the validator cache!\");\n    }\n  } else {\n    schema = SchemaCache.getSchema.call(this, report, schema);\n  }\n  var compiled = false;\n  if (!foundError) {\n    compiled = SchemaCompilation.compileSchema.call(this, report, schema);\n  }\n  if (!compiled) {\n    this.lastReport = report;\n    foundError = true;\n  }\n  var validated = false;\n  if (!foundError) {\n    validated = SchemaValidation.validateSchema.call(this, report, schema);\n  }\n  if (!validated) {\n    this.lastReport = report;\n    foundError = true;\n  }\n  if (options.schemaPath) {\n    report.rootSchema = schema;\n    schema = get(schema, options.schemaPath);\n    if (!schema) {\n      throw new Error(\"Schema path '\" + options.schemaPath + \"' wasn't found in the schema!\");\n    }\n  }\n  if (!foundError) {\n    JsonValidation.validate.call(this, report, schema, json);\n  }\n  if (callback) {\n    report.processAsyncTasks(this.options.asyncTimeout, callback);\n    return;\n  } else if (report.asyncTasks.length > 0) {\n    throw new Error(\"This validation has async tasks and cannot be done in sync mode, please provide callback argument.\");\n  }\n\n  // assign lastReport so errors are retrievable in sync mode\n  this.lastReport = report;\n  return report.isValid();\n};\nZSchema.prototype.getLastError = function () {\n  if (this.lastReport.errors.length === 0) {\n    return null;\n  }\n  var e = new Error();\n  e.name = \"z-schema validation error\";\n  e.message = this.lastReport.commonErrorMessage;\n  e.details = this.lastReport.errors;\n  return e;\n};\nZSchema.prototype.getLastErrors = function () {\n  return this.lastReport && this.lastReport.errors.length > 0 ? this.lastReport.errors : null;\n};\nZSchema.prototype.getMissingReferences = function (arr) {\n  arr = arr || this.lastReport.errors;\n  var res = [],\n    idx = arr.length;\n  while (idx--) {\n    var error = arr[idx];\n    if (error.code === \"UNRESOLVABLE_REFERENCE\") {\n      var reference = error.params[0];\n      if (res.indexOf(reference) === -1) {\n        res.push(reference);\n      }\n    }\n    if (error.inner) {\n      res = res.concat(this.getMissingReferences(error.inner));\n    }\n  }\n  return res;\n};\nZSchema.prototype.getMissingRemoteReferences = function () {\n  var missingReferences = this.getMissingReferences(),\n    missingRemoteReferences = [],\n    idx = missingReferences.length;\n  while (idx--) {\n    var remoteReference = SchemaCache.getRemotePath(missingReferences[idx]);\n    if (remoteReference && missingRemoteReferences.indexOf(remoteReference) === -1) {\n      missingRemoteReferences.push(remoteReference);\n    }\n  }\n  return missingRemoteReferences;\n};\nZSchema.prototype.setRemoteReference = function (uri, schema, validationOptions) {\n  if (typeof schema === \"string\") {\n    schema = JSON.parse(schema);\n  } else {\n    schema = Utils.cloneDeep(schema);\n  }\n  if (validationOptions) {\n    schema.__$validationOptions = normalizeOptions(validationOptions);\n  }\n  SchemaCache.cacheSchemaByUri.call(this, uri, schema);\n};\nZSchema.prototype.getResolvedSchema = function (schema) {\n  var report = new Report(this.options);\n  schema = SchemaCache.getSchema.call(this, report, schema);\n\n  // clone before making any modifications\n  schema = Utils.cloneDeep(schema);\n  var visited = [];\n\n  // clean-up the schema and resolve references\n  var cleanup = function (schema) {\n    var key,\n      typeOf = Utils.whatIs(schema);\n    if (typeOf !== \"object\" && typeOf !== \"array\") {\n      return;\n    }\n    if (schema.___$visited) {\n      return;\n    }\n    schema.___$visited = true;\n    visited.push(schema);\n    if (schema.$ref && schema.__$refResolved) {\n      var from = schema.__$refResolved;\n      var to = schema;\n      delete schema.$ref;\n      delete schema.__$refResolved;\n      for (key in from) {\n        if (from.hasOwnProperty(key)) {\n          to[key] = from[key];\n        }\n      }\n    }\n    for (key in schema) {\n      if (schema.hasOwnProperty(key)) {\n        if (key.indexOf(\"__$\") === 0) {\n          delete schema[key];\n        } else {\n          cleanup(schema[key]);\n        }\n      }\n    }\n  };\n  cleanup(schema);\n  visited.forEach(function (s) {\n    delete s.___$visited;\n  });\n  this.lastReport = report;\n  if (report.isValid()) {\n    return schema;\n  } else {\n    throw this.getLastError();\n  }\n};\n\n/**\n *\n * @param {*} schemaReader\n *\n * @returns {void}\n */\nZSchema.prototype.setSchemaReader = function (schemaReader) {\n  return ZSchema.setSchemaReader(schemaReader);\n};\nZSchema.prototype.getSchemaReader = function () {\n  return ZSchema.schemaReader;\n};\nZSchema.schemaReader = undefined;\n/*\n    static methods\n*/\nZSchema.setSchemaReader = function (schemaReader) {\n  ZSchema.schemaReader = schemaReader;\n};\nZSchema.registerFormat = function (formatName, validatorFunction) {\n  FormatValidators[formatName] = validatorFunction;\n};\nZSchema.unregisterFormat = function (formatName) {\n  delete FormatValidators[formatName];\n};\nZSchema.getRegisteredFormats = function () {\n  return Object.keys(FormatValidators);\n};\nZSchema.getDefaultOptions = function () {\n  return Utils.cloneDeep(defaultOptions);\n};\nZSchema.schemaSymbol = Utils.schemaSymbol;\nZSchema.jsonSymbol = Utils.jsonSymbol;\nmodule.exports = ZSchema;","map":null,"metadata":{},"sourceType":"script"}