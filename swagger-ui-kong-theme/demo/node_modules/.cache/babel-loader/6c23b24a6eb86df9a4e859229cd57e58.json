{"ast":null,"code":"const nonJsonTypes = [\"function\", \"symbol\", \"undefined\"];\nconst protectedProps = [\"constructor\", \"prototype\", \"__proto__\"];\nconst objectPrototype = Object.getPrototypeOf({});\n/**\n * Custom JSON serializer for Error objects.\n * Returns all built-in error properties, as well as extended properties.\n */\nexport function toJSON() {\n  // HACK: We have to cast the objects to `any` so we can use symbol indexers.\n  // see https://github.com/Microsoft/TypeScript/issues/1863\n  // tslint:disable: no-any no-unsafe-any\n  let pojo = {};\n  let error = this;\n  for (let key of getDeepKeys(error)) {\n    if (typeof key === \"string\") {\n      let value = error[key];\n      let type = typeof value;\n      if (!nonJsonTypes.includes(type)) {\n        pojo[key] = value;\n      }\n    }\n  }\n  // tslint:enable: no-any no-unsafe-any\n  return pojo;\n}\n/**\n * Returns own, inherited, enumerable, non-enumerable, string, and symbol keys of `obj`.\n * Does NOT return members of the base Object prototype, or the specified omitted keys.\n */\nexport function getDeepKeys(obj) {\n  let omit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  let keys = [];\n  // Crawl the prototype chain, finding all the string and symbol keys\n  while (obj && obj !== objectPrototype) {\n    keys = keys.concat(Object.getOwnPropertyNames(obj), Object.getOwnPropertySymbols(obj));\n    obj = Object.getPrototypeOf(obj);\n  }\n  // De-duplicate the list of keys\n  let uniqueKeys = new Set(keys);\n  // Remove any omitted keys\n  for (let key of omit.concat(protectedProps)) {\n    uniqueKeys.delete(key);\n  }\n  return uniqueKeys;\n}","map":null,"metadata":{},"sourceType":"module"}