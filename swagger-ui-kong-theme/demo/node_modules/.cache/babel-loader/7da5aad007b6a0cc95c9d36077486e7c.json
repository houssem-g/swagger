{"ast":null,"code":"\"use strict\";\n\nvar Report = require(\"./Report\");\nvar SchemaCache = require(\"./SchemaCache\");\nvar Utils = require(\"./Utils\");\nfunction mergeReference(scope, ref) {\n  if (Utils.isAbsoluteUri(ref)) {\n    return ref;\n  }\n  var joinedScope = scope.join(\"\"),\n    isScopeAbsolute = Utils.isAbsoluteUri(joinedScope),\n    isScopeRelative = Utils.isRelativeUri(joinedScope),\n    isRefRelative = Utils.isRelativeUri(ref),\n    toRemove;\n  if (isScopeAbsolute && isRefRelative) {\n    toRemove = joinedScope.match(/\\/[^\\/]*$/);\n    if (toRemove) {\n      joinedScope = joinedScope.slice(0, toRemove.index + 1);\n    }\n  } else if (isScopeRelative && isRefRelative) {\n    joinedScope = \"\";\n  } else {\n    toRemove = joinedScope.match(/[^#/]+$/);\n    if (toRemove) {\n      joinedScope = joinedScope.slice(0, toRemove.index);\n    }\n  }\n  var res = joinedScope + ref;\n  res = res.replace(/##/, \"#\");\n  return res;\n}\nfunction collectReferences(obj, results, scope, path) {\n  results = results || [];\n  scope = scope || [];\n  path = path || [];\n  if (typeof obj !== \"object\" || obj === null) {\n    return results;\n  }\n  if (typeof obj.id === \"string\") {\n    scope.push(obj.id);\n  }\n  if (typeof obj.$ref === \"string\" && typeof obj.__$refResolved === \"undefined\") {\n    results.push({\n      ref: mergeReference(scope, obj.$ref),\n      key: \"$ref\",\n      obj: obj,\n      path: path.slice(0)\n    });\n  }\n  if (typeof obj.$schema === \"string\" && typeof obj.__$schemaResolved === \"undefined\") {\n    results.push({\n      ref: mergeReference(scope, obj.$schema),\n      key: \"$schema\",\n      obj: obj,\n      path: path.slice(0)\n    });\n  }\n  var idx;\n  if (Array.isArray(obj)) {\n    idx = obj.length;\n    while (idx--) {\n      path.push(idx.toString());\n      collectReferences(obj[idx], results, scope, path);\n      path.pop();\n    }\n  } else {\n    var keys = Object.keys(obj);\n    idx = keys.length;\n    while (idx--) {\n      // do not recurse through resolved references and other z-schema props\n      if (keys[idx].indexOf(\"__$\") === 0) {\n        continue;\n      }\n      path.push(keys[idx]);\n      collectReferences(obj[keys[idx]], results, scope, path);\n      path.pop();\n    }\n  }\n  if (typeof obj.id === \"string\") {\n    scope.pop();\n  }\n  return results;\n}\nvar compileArrayOfSchemasLoop = function (mainReport, arr) {\n  var idx = arr.length,\n    compiledCount = 0;\n  while (idx--) {\n    // try to compile each schema separately\n    var report = new Report(mainReport);\n    var isValid = exports.compileSchema.call(this, report, arr[idx]);\n    if (isValid) {\n      compiledCount++;\n    }\n\n    // copy errors to report\n    mainReport.errors = mainReport.errors.concat(report.errors);\n  }\n  return compiledCount;\n};\nfunction findId(arr, id) {\n  var idx = arr.length;\n  while (idx--) {\n    if (arr[idx].id === id) {\n      return arr[idx];\n    }\n  }\n  return null;\n}\nvar compileArrayOfSchemas = function (report, arr) {\n  var compiled = 0,\n    lastLoopCompiled;\n  do {\n    // remove all UNRESOLVABLE_REFERENCE errors before compiling array again\n    var idx = report.errors.length;\n    while (idx--) {\n      if (report.errors[idx].code === \"UNRESOLVABLE_REFERENCE\") {\n        report.errors.splice(idx, 1);\n      }\n    }\n\n    // remember how many were compiled in the last loop\n    lastLoopCompiled = compiled;\n\n    // count how many are compiled now\n    compiled = compileArrayOfSchemasLoop.call(this, report, arr);\n\n    // fix __$missingReferences if possible\n    idx = arr.length;\n    while (idx--) {\n      var sch = arr[idx];\n      if (sch.__$missingReferences) {\n        var idx2 = sch.__$missingReferences.length;\n        while (idx2--) {\n          var refObj = sch.__$missingReferences[idx2];\n          var response = findId(arr, refObj.ref);\n          if (response) {\n            // this might create circular references\n            refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n            // it's resolved now so delete it\n            sch.__$missingReferences.splice(idx2, 1);\n          }\n        }\n        if (sch.__$missingReferences.length === 0) {\n          delete sch.__$missingReferences;\n        }\n      }\n    }\n\n    // keep repeating if not all compiled and at least one more was compiled in the last loop\n  } while (compiled !== arr.length && compiled !== lastLoopCompiled);\n  return report.isValid();\n};\nexports.compileSchema = function (report, schema) {\n  report.commonErrorMessage = \"SCHEMA_COMPILATION_FAILED\";\n\n  // if schema is a string, assume it's a uri\n  if (typeof schema === \"string\") {\n    var loadedSchema = SchemaCache.getSchemaByUri.call(this, report, schema);\n    if (!loadedSchema) {\n      report.addError(\"SCHEMA_NOT_REACHABLE\", [schema]);\n      return false;\n    }\n    schema = loadedSchema;\n  }\n\n  // if schema is an array, assume it's an array of schemas\n  if (Array.isArray(schema)) {\n    return compileArrayOfSchemas.call(this, report, schema);\n  }\n\n  // if we have an id than it should be cached already (if this instance has compiled it)\n  if (schema.__$compiled && schema.id && SchemaCache.checkCacheForUri.call(this, schema.id) === false) {\n    schema.__$compiled = undefined;\n  }\n\n  // do not re-compile schemas\n  if (schema.__$compiled) {\n    return true;\n  }\n  if (schema.id && typeof schema.id === \"string\") {\n    // add this to our schemaCache (before compilation in case we have references including id)\n    SchemaCache.cacheSchemaByUri.call(this, schema.id, schema);\n  }\n\n  // this method can be called recursively, so we need to remember our root\n  var isRoot = false;\n  if (!report.rootSchema) {\n    report.rootSchema = schema;\n    isRoot = true;\n  }\n\n  // delete all __$missingReferences from previous compilation attempts\n  var isValidExceptReferences = report.isValid();\n  delete schema.__$missingReferences;\n\n  // collect all references that need to be resolved - $ref and $schema\n  var refs = collectReferences.call(this, schema),\n    idx = refs.length;\n  while (idx--) {\n    // resolve all the collected references into __xxxResolved pointer\n    var refObj = refs[idx];\n    var response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n\n    // we can try to use custom schemaReader if available\n    if (!response) {\n      var schemaReader = this.getSchemaReader();\n      if (schemaReader) {\n        // it's supposed to return a valid schema\n        var s = schemaReader(refObj.ref);\n        if (s) {\n          // it needs to have the id\n          s.id = refObj.ref;\n          // try to compile the schema\n          var subreport = new Report(report);\n          if (!exports.compileSchema.call(this, subreport, s)) {\n            // copy errors to report\n            report.errors = report.errors.concat(subreport.errors);\n          } else {\n            response = SchemaCache.getSchemaByUri.call(this, report, refObj.ref, schema);\n          }\n        }\n      }\n    }\n    if (!response) {\n      var hasNotValid = report.hasError(\"REMOTE_NOT_VALID\", [refObj.ref]);\n      var isAbsolute = Utils.isAbsoluteUri(refObj.ref);\n      var isDownloaded = false;\n      var ignoreUnresolvableRemotes = this.options.ignoreUnresolvableReferences === true;\n      if (isAbsolute) {\n        // we shouldn't add UNRESOLVABLE_REFERENCE for schemas we already have downloaded\n        // and set through setRemoteReference method\n        isDownloaded = SchemaCache.checkCacheForUri.call(this, refObj.ref);\n      }\n      if (hasNotValid) {\n        // already has REMOTE_NOT_VALID error for this one\n      } else if (ignoreUnresolvableRemotes && isAbsolute) {\n        // ignoreUnresolvableRemotes is on and remote isAbsolute\n      } else if (isDownloaded) {\n        // remote is downloaded, so no UNRESOLVABLE_REFERENCE\n      } else {\n        Array.prototype.push.apply(report.path, refObj.path);\n        report.addError(\"UNRESOLVABLE_REFERENCE\", [refObj.ref]);\n        report.path = report.path.slice(0, -refObj.path.length);\n\n        // pusblish unresolved references out\n        if (isValidExceptReferences) {\n          schema.__$missingReferences = schema.__$missingReferences || [];\n          schema.__$missingReferences.push(refObj);\n        }\n      }\n    }\n    // this might create circular references\n    refObj.obj[\"__\" + refObj.key + \"Resolved\"] = response;\n  }\n  var isValid = report.isValid();\n  if (isValid) {\n    schema.__$compiled = true;\n  } else {\n    if (schema.id && typeof schema.id === \"string\") {\n      // remove this schema from schemaCache because it failed to compile\n      SchemaCache.removeFromCacheByUri.call(this, schema.id);\n    }\n  }\n\n  // we don't need the root pointer anymore\n  if (isRoot) {\n    report.rootSchema = undefined;\n  }\n  return isValid;\n};","map":null,"metadata":{},"sourceType":"script"}