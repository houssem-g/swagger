{"ast":null,"code":"\"use strict\";\n\nexports.jsonSymbol = Symbol.for(\"z-schema/json\");\nexports.schemaSymbol = Symbol.for(\"z-schema/schema\");\n\n/**\n * @param {object} obj\n *\n * @returns {string[]}\n */\nvar sortedKeys = exports.sortedKeys = function (obj) {\n  return Object.keys(obj).sort();\n};\n\n/**\n *\n * @param {string} uri\n *\n * @returns {boolean}\n */\nexports.isAbsoluteUri = function (uri) {\n  return /^https?:\\/\\//.test(uri);\n};\n\n/**\n *\n * @param {string} uri\n *\n * @returns {boolean}\n */\nexports.isRelativeUri = function (uri) {\n  // relative URIs that end with a hash sign, issue #56\n  return /.+#/.test(uri);\n};\nexports.whatIs = function (what) {\n  var to = typeof what;\n  if (to === \"object\") {\n    if (what === null) {\n      return \"null\";\n    }\n    if (Array.isArray(what)) {\n      return \"array\";\n    }\n    return \"object\"; // typeof what === 'object' && what === Object(what) && !Array.isArray(what);\n  }\n\n  if (to === \"number\") {\n    if (Number.isFinite(what)) {\n      if (what % 1 === 0) {\n        return \"integer\";\n      } else {\n        return \"number\";\n      }\n    }\n    if (Number.isNaN(what)) {\n      return \"not-a-number\";\n    }\n    return \"unknown-number\";\n  }\n  return to; // undefined, boolean, string, function\n};\n\n/**\n *\n * @param {*} json1\n * @param {*} json2\n * @param {*} [options]\n *\n * @returns {boolean}\n */\nexports.areEqual = function areEqual(json1, json2, options) {\n  options = options || {};\n  var caseInsensitiveComparison = options.caseInsensitiveComparison || false;\n\n  // http://json-schema.org/latest/json-schema-core.html#rfc.section.3.6\n\n  // Two JSON values are said to be equal if and only if:\n  // both are nulls; or\n  // both are booleans, and have the same value; or\n  // both are strings, and have the same value; or\n  // both are numbers, and have the same mathematical value; or\n  if (json1 === json2) {\n    return true;\n  }\n  if (caseInsensitiveComparison === true && typeof json1 === \"string\" && typeof json2 === \"string\" && json1.toUpperCase() === json2.toUpperCase()) {\n    return true;\n  }\n  var i, len;\n\n  // both are arrays, and:\n  if (Array.isArray(json1) && Array.isArray(json2)) {\n    // have the same number of items; and\n    if (json1.length !== json2.length) {\n      return false;\n    }\n    // items at the same index are equal according to this definition; or\n    len = json1.length;\n    for (i = 0; i < len; i++) {\n      if (!areEqual(json1[i], json2[i], {\n        caseInsensitiveComparison: caseInsensitiveComparison\n      })) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // both are objects, and:\n  if (exports.whatIs(json1) === \"object\" && exports.whatIs(json2) === \"object\") {\n    // have the same set of property names; and\n    var keys1 = sortedKeys(json1);\n    var keys2 = sortedKeys(json2);\n    if (!areEqual(keys1, keys2, {\n      caseInsensitiveComparison: caseInsensitiveComparison\n    })) {\n      return false;\n    }\n    // values for a same property name are equal according to this definition.\n    len = keys1.length;\n    for (i = 0; i < len; i++) {\n      if (!areEqual(json1[keys1[i]], json2[keys1[i]], {\n        caseInsensitiveComparison: caseInsensitiveComparison\n      })) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n};\n\n/**\n *\n * @param {*[]} arr\n * @param {number[]} [indexes]\n *\n * @returns {boolean}\n */\nexports.isUniqueArray = function (arr, indexes) {\n  var i,\n    j,\n    l = arr.length;\n  for (i = 0; i < l; i++) {\n    for (j = i + 1; j < l; j++) {\n      if (exports.areEqual(arr[i], arr[j])) {\n        if (indexes) {\n          indexes.push(i, j);\n        }\n        return false;\n      }\n    }\n  }\n  return true;\n};\n\n/**\n *\n * @param {*} bigSet\n * @param {*} subSet\n *\n * @returns {*[]}\n */\nexports.difference = function (bigSet, subSet) {\n  var arr = [],\n    idx = bigSet.length;\n  while (idx--) {\n    if (subSet.indexOf(bigSet[idx]) === -1) {\n      arr.push(bigSet[idx]);\n    }\n  }\n  return arr;\n};\n\n// NOT a deep version of clone\nexports.clone = function (src) {\n  if (typeof src === \"undefined\") {\n    return void 0;\n  }\n  if (typeof src !== \"object\" || src === null) {\n    return src;\n  }\n  var res, idx;\n  if (Array.isArray(src)) {\n    res = [];\n    idx = src.length;\n    while (idx--) {\n      res[idx] = src[idx];\n    }\n  } else {\n    res = {};\n    var keys = Object.keys(src);\n    idx = keys.length;\n    while (idx--) {\n      var key = keys[idx];\n      res[key] = src[key];\n    }\n  }\n  return res;\n};\nexports.cloneDeep = function (src) {\n  var vidx = 0,\n    visited = new Map(),\n    cloned = [];\n  function cloneDeep(src) {\n    if (typeof src !== \"object\" || src === null) {\n      return src;\n    }\n    var res, idx, cidx;\n    cidx = visited.get(src);\n    if (cidx !== undefined) {\n      return cloned[cidx];\n    }\n    visited.set(src, vidx++);\n    if (Array.isArray(src)) {\n      res = [];\n      cloned.push(res);\n      idx = src.length;\n      while (idx--) {\n        res[idx] = cloneDeep(src[idx]);\n      }\n    } else {\n      res = {};\n      cloned.push(res);\n      var keys = Object.keys(src);\n      idx = keys.length;\n      while (idx--) {\n        var key = keys[idx];\n        res[key] = cloneDeep(src[key]);\n      }\n    }\n    return res;\n  }\n  return cloneDeep(src);\n};\n\n/*\n  following function comes from punycode.js library\n  see: https://github.com/bestiejs/punycode.js\n*/\n/*jshint -W016*/\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nexports.ucs2decode = function (string) {\n  var output = [],\n    counter = 0,\n    length = string.length,\n    value,\n    extra;\n  while (counter < length) {\n    value = string.charCodeAt(counter++);\n    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n      // high surrogate, and there is a next character\n      extra = string.charCodeAt(counter++);\n      if ((extra & 0xFC00) == 0xDC00) {\n        // low surrogate\n        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n      } else {\n        // unmatched surrogate; only append this code unit, in case the next\n        // code unit is the high surrogate of a surrogate pair\n        output.push(value);\n        counter--;\n      }\n    } else {\n      output.push(value);\n    }\n  }\n  return output;\n};\n/*jshint +W016*/","map":null,"metadata":{},"sourceType":"script"}